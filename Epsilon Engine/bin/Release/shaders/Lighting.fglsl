#version 330 core

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 blurImage;

in vec2 TexCoords;

uniform sampler2D gPositionDepth;
uniform sampler2D gNormal;
uniform sampler2D gAlbedoSpec;
uniform sampler2D ssaoColorBufferBlur;
uniform float exposure;
struct Light {
    vec3 Position;
    vec3 Color;

    float Linear;
    float Quadratic;
};

const int NR_LIGHTS = 32;
uniform vec3 viewPos;
uniform vec3 lightDir;
uniform bool hdr;
vec3 FragPos;
vec3 Normal;
vec3 Diffuse;
float Specular;
float Depth;
vec3 CalculateDirectional();
vec3 calculatePoint(vec3 LightPos);

    const float gamma = 2.2;

vec3 HDR(vec3 image)
{
    vec3 result = vec3(1.0) - exp(-image.xyz * exposure);
    result.xyz = pow(result.xyz, vec3(1.0 / gamma));
    return (result.xyz - 0.5f) * 1.1f + 0.5f;
}



vec3 ambient;
void main()
{
/*
vec3 lights[7];

lights[0] = vec3(-1.14, -9.39, -6.86);
lights[1] = vec3(-41.77, 40.36, -58.75);
lights[2] = vec3(-7.04, 42.53, -96.31);
lights[3] = vec3(-56.65, 42.09, -98.20);
lights[4] = vec3(-142.2, 33.23, -92.66);
lights[5] = vec3(51.2, 42.32, -80.82);
lights[6] = vec3(35.85, 43.70, -45.7);
*/

vec3 lights[7];

lights[0] = vec3(-39.78, 12.85, -22.59);
lights[1] = vec3(-39.77, 10.36, 2.46);
lights[2] = vec3(23.04, 16.54, 2.60);
lights[3] = vec3(-21.37, 17.39, 26.49);
lights[4] = vec3(-31.60, 11.13, -3.77);
lights[5] = vec3(78.55, 17.0, -19.0);
lights[6] = vec3(78.55, 17.0, 27.65);


    FragColor.a = 1.0;
    blurImage.a = 1.0;
    // Retrieve data from gbuffer
    FragPos = texture(gPositionDepth, TexCoords).rgb;
    Depth = texture(gPositionDepth, TexCoords).a;
    Normal = normalize(texture(gNormal, TexCoords).rgb);
    Diffuse = texture(gAlbedoSpec, TexCoords).rgb;
    Specular = texture(gAlbedoSpec, TexCoords).a;
    vec3 AmbientOcclusion = vec3(texture(ssaoColorBufferBlur, TexCoords).r);
    ambient = Diffuse *  0.05 * vec3(1.0, 1.0, 1.5);

    vec3 light = CalculateDirectional();

    for(int i = 0 ; i < 7 ; i++)
      light += calculatePoint(lights[i]);


    light += ambient;

    if(hdr == true)
    {
      vec3 testHDR = HDR(light.rgb * clamp(AmbientOcclusion, 0.1, 1.0));
      FragColor.rgb =light.rgb * clamp(AmbientOcclusion, 0.1, 1.0);
      float brightness = dot(testHDR.rgb, vec3(0.2126, 0.7152, 0.0722));
      if(brightness > 0.7)
      blurImage.rgb = FragColor.rgb;
    }
    else
    {
    vec3 testHDR = HDR(light.rgb);
    FragColor.rgb =  light.rgb;
    float brightness = dot(testHDR.rgb, vec3(0.2126, 0.7152, 0.0722));
    if(brightness > 0.7)
    blurImage.rgb = FragColor.rgb;
    }
}

vec3 CalculateDirectional()
{
    vec3 lightcolor = normalize(vec3(250, 190, 108));
    vec3 lightdirection = lightDir;
    if(clamp(lightDir.y + 0.1, 0.0, 1.0) < 0.0){
      vec3 lightdirection = -lightDir;
      lightcolor = normalize(vec3(0.5, 0.5, 0.5));
      }

    float diff =  max(dot(lightDir, Normal), 0.0);
    vec3 diffuse = diff * Diffuse;

    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 halfwayDir = normalize(lightDir + viewDir);
    vec3 specular = pow(max(dot(Normal, halfwayDir), 0.0),128) * vec3(0.5) * Specular * diff;

    return mix(ambient, vec3(diffuse + specular * vec3(1.0, 1.0, 1.1) * 3) * lightcolor * 2, clamp(lightDir.y + 0.1, 0.0, 1.0));



}

vec3 calculatePoint(vec3 LightPos)
{

    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 lightDirection = normalize(LightPos - FragPos);
    float diff =  max(dot(lightDirection, Normal), 0.0);
    vec3 diffuse = diff * Diffuse;

    float distance = length(LightPos - FragPos);
    //float attenuation = 1.0f / (1.0 + 0.35 * distance + 1.8 * (distance*distance));
    float attenuation = 0.0f;
    //attenuation = 1.0f /  (distance)(distance);
    //attenuation = 1.0f / (1.0 + 0.35 * distance + 1.8 * (distance*distance));
    float minLight = 0.05;
    float b = 1.0 / 30.0;
    float radius = sqrt(1.0 / (b * minLight));
    b = 1.0 / (radius*radius * minLight);
    attenuation = clamp(1.0 - distance/radius, 0.0, 1.0);
    attenuation *= attenuation;

    vec3 halfwayDir = normalize(lightDirection + viewDir);
    float spec = pow(max(dot(Normal, halfwayDir), 0.0),128.0);
    vec3 specular = vec3(0.5) * spec * Specular;
    diffuse  *= attenuation;
    specular *= attenuation;

    return  (diffuse + specular);
}
