#version 440 core

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 blurImage;

in vec2 TexCoords;

layout (binding = 0) uniform sampler2D gPositionDepth;
layout (binding = 1) uniform sampler2D gNormal;
layout (binding = 2) uniform sampler2D gAlbedoSpec;
layout (binding = 3) uniform sampler2D ssaoColorBufferBlur;
layout (binding = 4) uniform sampler2D shadowMap;

uniform float exposure;
uniform mat4 lightSpaceMatrix;

vec3 SkyColor = vec3(0.5,0.5,0.5);
vec3 NightFog = vec3(0.1,0.1,0.1);

struct Light {
    vec3 Position;
    vec3 Color;

    float Linear;
    float Quadratic;
};

vec2 poissonDisk[16] = vec2[]( 
   vec2( -0.94201624, -0.39906216 ), 
   vec2( 0.94558609, -0.76890725 ), 
   vec2( -0.094184101, -0.92938870 ), 
   vec2( 0.34495938, 0.29387760 ), 
   vec2( -0.91588581, 0.45771432 ), 
   vec2( -0.81544232, -0.87912464 ), 
   vec2( -0.38277543, 0.27676845 ), 
   vec2( 0.97484398, 0.75648379 ), 
   vec2( 0.44323325, -0.97511554 ), 
   vec2( 0.53742981, -0.47373420 ), 
   vec2( -0.26496911, -0.41893023 ), 
   vec2( 0.79197514, 0.19090188 ), 
   vec2( -0.24188840, 0.99706507 ), 
   vec2( -0.81409955, 0.91437590 ), 
   vec2( 0.19984126, 0.78641367 ), 
   vec2( 0.14383161, -0.14100790 ) 
);

// Returns a random number based on a vec3 and an int.
float random(vec3 seed, int i){
    vec4 seed4 = vec4(seed,i);
    float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
    return fract(sin(dot_product) * 43758.5453);
}

const int NR_LIGHTS = 32;
uniform vec3 viewPos;
uniform vec3 lightDir;
uniform bool hdr;
vec3 FragPos;
vec3 Normal;
vec3 Diffuse;
float Specular;
float Depth;
vec3 CalculateDirectional();
vec3 calculatePoint(vec3 LightPos);

    const float gamma = 2.2;

vec3 HDR(vec3 image)
{
    vec3 result = vec3(1.0) - exp(-image.xyz * exposure);
    result.xyz = pow(result.xyz, vec3(1.0 / gamma));
    return (result.xyz - 0.5f) * 1.1f + 0.5f;
}

const float shadowDistance = 100.0f;
const float fadeDistance = 10.0f;
float ShadowCalculation(vec4 fragPosLightSpace)
{
    
    // perform perspective divide
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    // Transform to [0,1] range
    projCoords = projCoords * 0.5 + 0.5;
    // Get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)
    float closestDepth = texture(shadowMap, projCoords.xy).r; 
    // Get depth of current fragment from light's perspective
    float currentDepth = projCoords.z;
    // Calculate bias (based on depth map resolution and slope)
    float bias = 0.01;//max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);
    // Check whether current frag pos is in shadow
     float shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0;
    // PCF
    //float shadow = 0.0;
    
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    
/*
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;        
        }    
    }
    shadow /= 9.0;
*/
    // Keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
  /*  if(projCoords.z > 1.0)
        shadow = 0.0;
*/

    return shadow;
}

float linstep(float low, float high, float v)
{
    return clamp((v - low)/(high - low), 0.0, 1.0);
}

float sampleVarianceShadowMapping(vec4 coords)
{
    float shadow;

    vec3 projCoords = coords.xyz / coords.w;
    projCoords = projCoords * 0.5 + 0.5;
    float compare = projCoords.z;
    float depthMap = texture(shadowMap, projCoords.xy).r;

    vec2 moments = vec2(depthMap, pow(depthMap, 2));

    float p = step(compare, moments.x);
    float variance = max(moments.y - (moments.x * moments.x), 0.00002);

    float d = compare - moments.x;
    float pMax = linstep(0.1, 1.0, variance / (variance + d*d));

    shadow = 1 - min(max(p, pMax), 1.0f);

        if(projCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

vec3 ambient;
float shadow = 0.0;


const float density = 0.006;
const float gradient = 3.0;

void main()
{


        

/*
vec3 lights[7];

lights[0] = vec3(-1.14, -9.39, -6.86);
lights[1] = vec3(-41.77, 40.36, -58.75);
lights[2] = vec3(-7.04, 42.53, -96.31);
lights[3] = vec3(-56.65, 42.09, -98.20);
lights[4] = vec3(-142.2, 33.23, -92.66);
lights[5] = vec3(51.2, 42.32, -80.82);
lights[6] = vec3(35.85, 43.70, -45.7);
*/

vec3 lights[7];

lights[0] = vec3(-39.78, 12.85, -22.59);
lights[1] = vec3(-39.77, 10.36, 2.46);
lights[2] = vec3(23.04, 16.54, 2.60);
lights[3] = vec3(-21.37, 17.39, 26.49);
lights[4] = vec3(-31.60, 11.13, -3.77);
lights[5] = vec3(122.55, 17.0, -19.0);
lights[6] = vec3(122.55, 17.0, 27.65);


    FragColor.a = 1.0;
    blurImage.a = 1.0;
    // Retrieve data from gbuffer
    FragPos = texture(gPositionDepth, TexCoords).rgb;
    Depth = texture(gPositionDepth, TexCoords).a;
    Normal = texture(gNormal, TexCoords).rgb;
    Diffuse = texture(gAlbedoSpec, TexCoords).rgb;
    Specular = texture(gAlbedoSpec, TexCoords).a;
    vec4 FragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0f);
    vec3 AmbientOcclusion = vec3(texture(ssaoColorBufferBlur, TexCoords).r);
    ambient = clamp(Diffuse *  0.03 * normalize(vec3(1.0, 1.0, 1.5)), 0.0, 1.0);

    shadow = sampleVarianceShadowMapping(FragPosLightSpace); //ShadowCalculation(FragPosLightSpace); 

    vec3 light = CalculateDirectional();

    for(int i = 0 ; i < 7 ; i++)
      light += calculatePoint(lights[i]);


    light += ambient;

    float distance = length(viewPos - FragPos);

    float visibility = exp(-pow((distance*density), gradient));

    if(hdr == true)
    {
        FragColor.rgb = mix(SkyColor,light.rgb * clamp(AmbientOcclusion, 0.1, 1.0), visibility);
        vec3 testHDR = HDR(FragColor.rgb);
        float brightness = dot(testHDR.rgb, vec3(0.2126, 0.7152, 0.0722));
        if(brightness > 0.8)
        blurImage.rgb = FragColor.rgb;
    }
    
    else
    {
    FragColor.rgb =  mix(SkyColor, light.rgb, visibility);
    vec3 testHDR = HDR(FragColor.rgb);
    float brightness = dot(testHDR.rgb, vec3(0.2126, 0.7152, 0.0722));
    if(brightness > 0.8)
    blurImage.rgb = FragColor.rgb;
    }
}

vec3 CalculateDirectional()
{
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 lightcolor = normalize(vec3(250, 190, 108));
    vec3 lightdirection = lightDir;
    if(clamp(lightDir.y + 0.1, 0.0, 1.0) < 0.0){
      vec3 lightdirection = -lightDir;
      lightcolor = normalize(vec3(0.5, 0.5, 0.5));
      }

    float diff =  max(dot(lightDir, Normal), 0.0);
    vec3 diffuse = diff * Diffuse;

    vec3 halfwayDir = normalize(lightDir + viewDir);
    vec3 specular = pow(max(dot(Normal, halfwayDir), 0.0), clamp(Specular * 128, 16.0, 128.0)) * vec3(Specular) * diff * 0.5;

    //return ((1.0 - shadow) * (diffuse + specular));

    return mix(ambient, clamp(1.0 - shadow, 0.0, 1.0) * vec3(diffuse + specular * 3) * lightcolor * 2, clamp(lightDir.y + 0.1, 0.0, 1.0));



}

vec3 calculatePoint(vec3 LightPos)
{

    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 lightDirection = normalize(LightPos - FragPos);
    float diff =  max(dot(lightDirection, Normal), 0.0);
    vec3 diffuse = diff * Diffuse;

    float distance = length(LightPos - FragPos);
    //float attenuation = 1.0f / (1.0 + 0.35 * distance + 1.8 * (distance*distance));
    float attenuation = 0.0f;
    //attenuation = 1.0f /  (distance)(distance);
    //attenuation = 1.0f / (1.0 + 0.35 * distance + 1.8 * (distance*distance));
    float minLight = 0.02;
    float b = 1.0 / 20.0;
    float radius = sqrt(1.0 / (b * minLight));
    b = 1.0 / (radius*radius * minLight);
    attenuation = clamp(1.0 - distance/radius, 0.0, 1.0);
    attenuation *= attenuation;

    vec3 halfwayDir = normalize(lightDirection + viewDir);
    float refractiveFactor = dot(viewDir, Normal);
    float spec = pow(max(dot(Normal, halfwayDir), 0.0), clamp((1 - refractiveFactor) * 128, 16.0, 128.0));
    vec3 specular = vec3(1.0) * spec * Specular;
    diffuse  *= attenuation;
    specular *= attenuation;

    return  (specular * clamp( 1 - refractiveFactor, 0.1, 0.9) + diffuse);
}
