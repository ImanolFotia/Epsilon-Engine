#version 440 core

in vec2 TexCoords;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 blurImage;

layout (binding = 0) uniform sampler2D gDepth;
layout (binding = 1) uniform sampler2D gNormal;
layout (binding = 2) uniform sampler2D gAlbedoSpec;
layout (binding = 3) uniform sampler2D ssaoColorBufferBlur;
layout (binding = 4) uniform sampler2DShadow shadowMap;
layout (binding = 5) uniform sampler2D gExtraComponents;
layout (binding = 6) uniform sampler2D gLightAccumulation; 

uniform float exposure;
uniform mat4 lightSpaceMatrix;
uniform vec3 viewPos;
uniform vec3 lightDir;
uniform bool hdr;
uniform int NUMLIGHTS;
const int NR_LIGHTS = 32;
uniform vec3 LightPositions[NR_LIGHTS];
uniform mat4 projection;
uniform vec3 uViewDir;
uniform mat4 view;
uniform mat4 uView;



const float gamma = 2.2;
const float shadowDistance = 100.0f;
const float fadeDistance = 10.0f;
const vec3 SkyColor = normalize(vec3(186,162,135));

const vec3 SkyColor0 = normalize(vec3(205, 109, 39));
const vec3 SkyColor1 = normalize(vec3(256, 75, 20));
const float density = 0.00015;
const float gradient = 1.5;


vec3 FragPos;
vec3 Normal;
vec3 Diffuse;
float Specular;
float Depth;
vec3 ambient;
vec3 SpecDiff;
float AmbientOcclusion;
float shadow = 0.0;
vec4 ExtraComponents;

vec2 poissonDisk[16] = vec2[]( 
   vec2( -0.94201624, -0.39906216 ), 
   vec2( 0.94558609, -0.76890725 ), 
   vec2( -0.094184101, -0.92938870 ), 
   vec2( 0.34495938, 0.29387760 ), 
   vec2( -0.91588581, 0.45771432 ), 
   vec2( -0.81544232, -0.87912464 ), 
   vec2( -0.38277543, 0.27676845 ), 
   vec2( 0.97484398, 0.75648379 ), 
   vec2( 0.44323325, -0.97511554 ), 
   vec2( 0.53742981, -0.47373420 ), 
   vec2( -0.26496911, -0.41893023 ), 
   vec2( 0.79197514, 0.19090188 ), 
   vec2( -0.24188840, 0.99706507 ), 
   vec2( -0.81409955, 0.91437590 ), 
   vec2( 0.19984126, 0.78641367 ), 
   vec2( 0.14383161, -0.14100790 ) 
);

float random(vec3 seed, int i){
    vec4 seed4 = vec4(seed,i);
    float dot_product = dot(seed4, vec4(12.9898,78.233,45.164,94.673));
    return fract(sin(dot_product) * 43758.5453);
}

vec3 HDR(vec3 image)
{
    vec3 result = vec3(1.0) - exp(-image.xyz * exposure);
    result.xyz = pow(result.xyz, vec3(1.0 / gamma));
    return (result.xyz - 0.5f) * 1.1f + 0.5f;
}

float poissonShadowMapping(vec4 fragPosLightSpace){

    float visibility = 1.0;
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    fragPosLightSpace = fragPosLightSpace * 0.5 + 0.5;
    
    vec3 normal = normalize(Normal);
    float bias = max(0.01 * (1.0 - dot(normal, lightDir)), 0.005);

    for (int i=0;i<4;i++){
        int index = int(16.0*random(floor(FragPos.xyz*1000.0), i))%16;
        visibility -= 0.2*(texture(shadowMap, vec3(fragPosLightSpace.xy+ poissonDisk[index]/2000.0, fragPosLightSpace.z - bias)/fragPosLightSpace.w).r);
    }

    return visibility;
}

float calculateAttenuation(float radius, float distance);


float NEAR = 0.1;
float FAR = 3000.0;
float LinearizeDepth(in float depth, in mat4 projMatrix) {
  return projMatrix[3][2] / (depth - projMatrix[2][2]);
}

float attenuation = 0.0f;
float minLight = 0.03;
float b = 1.0 / 40.0;
float radius = sqrt(1.0 / (b * minLight));


vec3 CalculateDirectional();
vec3 calculatePoint(vec3 LightPos);

vec3 WorldPosFromDepth(float depth) {
    float z = depth * 2.0 - 1.0;

    vec4 clipSpacePosition = vec4(TexCoords * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = projection * clipSpacePosition;

    // Perspective division
    viewSpacePosition /= viewSpacePosition.w;

    vec4 worldSpacePosition = view * viewSpacePosition;

    return worldSpacePosition.xyz;
}



/*
vec3 ComputeSHIrradiance(in vec3 normal)
{
    // Compute the cosine lobe in SH, oriented about the normal direction
    SH9 shCosine = SHCosineLobe(normal);

    // Compute the SH dot product to get irradiance
    vec3 irradiance = 0.0f;
    for(uint i = 0; i < 9; ++i)
        irradiance += radiance.c[i] * shCosine.c[i];

    return irradiance;
}
*/

uniform float time;

const float PI = 3.14159265359;

vec3 calculatePointPBR(vec3 pos);
vec3 CalculateDirectionalPBR();
float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
  
    float nom   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
  
    return nom / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
  
    return nom / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = GeometrySchlickGGX(NdotV, roughness);
    float ggx1  = GeometrySchlickGGX(NdotL, roughness);
  
    return ggx1 * ggx2;
}
vec3 F;
vec3 kS;
vec3 kD;

vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}  

float orenNayarDiffuse(
  vec3 lightDirection,
  vec3 viewDirection,
  vec3 surfaceNormal,
  float roughness,
  float albedo) {
  
  float LdotV = dot(lightDirection, viewDirection);
  float NdotL = dot(lightDirection, surfaceNormal);
  float NdotV = dot(surfaceNormal, viewDirection);

  float s = LdotV - NdotL * NdotV;
  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));

  float sigma2 = roughness * roughness;
  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33) + 0.000001);
  float B = 0.45 * sigma2 / (sigma2 + 0.09) + 0.00001;

  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;
}

void main()
{

    FragColor.a = 1.0;
    blurImage.a = 1.0;



    //originDepth = LinearizeDepth(originDepth, projection);
    FragPos = WorldPosFromDepth(texture(gDepth, TexCoords).r);

    float distance = length(viewPos - FragPos);
    vec3  V = normalize(viewPos - FragPos);

    float visibility = exp(-pow((distance*density), gradient));

    Normal = texture(gNormal, TexCoords).rgb;

    Normal = normalize(Normal);



    ExtraComponents = texture(gExtraComponents, TexCoords).rgba;

    Diffuse = texture(gAlbedoSpec, TexCoords).rgb;



    if(ExtraComponents.y > 0.1){
    	FragColor.rgb = mix(SkyColor, Diffuse, visibility);
    	blurImage.rgb = mix(SkyColor, Diffuse, visibility);
    	return;
    }

    Specular = texture(gNormal, TexCoords).a;
    SpecDiff = Diffuse * Specular;
    AmbientOcclusion = texture(ssaoColorBufferBlur, TexCoords).r;
    vec4 FragPosLightSpace = lightSpaceMatrix * vec4(FragPos, 1.0f);
    
    vec3 F0 = vec3(0.04);
    F0      = mix(F0, Diffuse, ExtraComponents.x);

    F = fresnelSchlickRoughness(max(dot(Normal, V), 0.0), F0, Specular);
    //F.x = clamp(F.x, 0.03, 1.0);
    //F.y = clamp(F.y, 0.03, 1.0);
    //F.z = clamp(F.z, 0.03, 1.0);
    kS = F;
    kD = vec3(1.0) - kS;
    kD *= 1.0 - ExtraComponents.x;


    //vec3 shc = sphericalHarmonics(Normal) * u_scaleFactor;
    vec3 irradiance = texture(gLightAccumulation, TexCoords).rgb;
    //vec3 diff = irradiance * Diffuse;
    //ambient = kD * (shc*Diffuse);
    ambient = /*vec3(shc);//*/ clamp(Diffuse *  0.0008, 0.0, 1.0);

    shadow  = poissonShadowMapping(FragPosLightSpace);

    vec3 light = CalculateDirectionalPBR();

    b = 1.0 / (radius*radius * minLight);
    float change = sin(time)*10.0;
    float change2 = cos(time)*10.0;
    for(int i = 0 ; i < NUMLIGHTS ; i++)
    {
      
      light += calculatePointPBR(LightPositions[i]);
    }

    //light += calculatePointPBR(viewPos);

    //light += irradiance * vec3(ExtraComponents.r) * kS;
    light += ((irradiance * Diffuse) * kD);
    //light += ambient;
    
    if(hdr)
    light *= AmbientOcclusion;

    vec3 fogColor = mix(SkyColor0, SkyColor1, lightDir.y);

    FragColor.rgb = mix(SkyColor, light, visibility);
    vec3 testHDR = FragColor.rgb;
    float brightness = dot(testHDR.rgb /** ((exposure - 3.0) <= 0 ? 1.0 : (exposure - 3.0))*/, vec3(0.2126, 0.7152, 0.0722));

    if(brightness > 1.0)
        blurImage.rgb = vec3(0.0);//FragColor.rgb;

            FragColor.a = 1.0;
    blurImage.a = 1.0;

}

vec3 CalculateDirectional()
{
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 lightcolor = normalize(vec3(205, 109, 39));
    vec3 lightcolor2 = normalize(vec3(256, 75, 20));
    vec3 lightdirection = lightDir;

    if(clamp(lightDir.y + 0.1, 0.0, 1.0) < 0.0)
    {
      vec3 lightdirection = -lightDir;
      lightcolor = normalize(vec3(0.5, 0.5, 0.5));
    }

    float diff =  max(dot(lightDir, Normal), 0.0);
    vec3 diffuse = diff * Diffuse;

    vec3 halfwayDir = normalize(lightDir + viewDir);
    vec3 specular = pow(max(dot(Normal, halfwayDir), 0.0), clamp(Specular * 256, 16.0, 256.0)) * vec3(Specular) * 1.5;

    //ambient = Diffuse * vec3(mix(0.005, 0.03, clamp(lightDir.y + 0.1, 0.0, 1.0)));

    vec3 lc = mix(lightcolor2, lightcolor, lightDir.y);

    return mix(vec3(0.0), clamp(1.0 - shadow, 0.0, 1.0) * vec3(diffuse + specular) * lc, clamp(lightDir.y + 0.1, 0.0, 1.0)) * 2.0;

}


vec3 calculatePoint(vec3 LightPos)
{
	vec3 lightcolor = normalize(LightPos) *0.5+ 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 lightDirection = normalize(LightPos - FragPos);
    float diff =  max(dot(lightDirection, Normal), 0.0);
    vec3 diffuse = vec3(diff) * Diffuse;

    float distance = length(LightPos - FragPos);
    attenuation = clamp(1.0 - distance/radius, 0.0, 1.0);
    attenuation *= attenuation;
    vec3 halfwayDir = normalize(lightDirection + viewDir);
    float refractiveFactor = dot(viewDir, Normal);
    float spec = pow(max(dot(Normal, halfwayDir), 0.0), max(clamp((1 - refractiveFactor) * 256, 16.0, 256.0), clamp((1 - Specular) * 256, 16.0, 256.0))) ;
    vec3 specular = vec3(1.0) * spec * SpecDiff;
    diffuse  *= attenuation;
    specular *= attenuation * 25;

    return  (specular * clamp( 1 - refractiveFactor, 0.1, 0.9) + diffuse) * lightcolor;
}

vec3 CalculateDirectionalPBR()
{
    // calculate per-light radiance
        vec3 lightcolor = vec3(0.3);//normalize(vec3(205, 109, 39));
        vec3 V = normalize(viewPos - FragPos);
        vec3 L = normalize(lightDir);
        vec3 H = normalize(V + L);  
        
        // cook-torrance brdf
        float NDF = DistributionGGX(Normal, H, clamp(Specular, 0.03, 1.0));        
        float G   = GeometrySmith(Normal, V, L, Specular);      
        
        vec3 nominator    = NDF * G * F;
        float denominator = (4 * max(dot(V, Normal), 0.0) * max(dot(L, Normal), 0.0)) + 0.001; 
        vec3 brdf = nominator / denominator;
            
        // add to outgoing radiance Lo
        float NdotL = max(dot(Normal, L), 0.0); // max(orenNayarDiffuse(L, V, Normal, clamp(Specular, 0.03, 1.0), 1.0), 0.0);//              
        vec3 Lo = (kD * Diffuse / PI + brdf) * NdotL; 
        return mix(vec3(0.0), Lo * clamp(1.0 - shadow, 0.0, 1.0) * lightcolor, clamp(lightDir.y + 0.1, 0.0, 1.0))*4.0;
}
vec3 calculatePointPBR(vec3 pos)
{
  // calculate per-light radiance
        vec3 V = normalize(viewPos - FragPos);
        vec3 L = normalize(pos - FragPos);
        vec3 H = normalize(V + L);
        //float distance    = length(pos - FragPos);
        float distance = length(pos - FragPos);
        attenuation = calculateAttenuation(100, distance);//1.0 / (1.0 + 0.1/*factor*/ * pow(distance, 2));
        attenuation *= smoothstep(40.0, 35.0, distance);
        vec3 radiance     = vec3(1.0) * attenuation;        
        
        // cook-torrance brdf
        float NDF = DistributionGGX(Normal, H, clamp(Specular, 0.03, 1.0));        
        float G   = GeometrySmith(Normal, V, L, Specular);      
        
        vec3 nominator    = NDF * G * F;
        float denominator = (4 * max(dot(V, Normal), 0.0) * max(dot(L, Normal), 0.0)) + 0.001; 
        vec3 brdf = nominator / denominator;
            
        // add to outgoing radiance Lo
        float NdotL = max(dot(Normal, L), 0.0); //max(orenNayarDiffuse(L, V, Normal, clamp(Specular, 0.03, 1.0), 1.0), 0.0);//               
        vec3 Lo = (kD * Diffuse / PI + brdf) * radiance * NdotL; 
        return Lo /* normalize(vec3(205, 109, 39))*/;
}

float calculateAttenuation(float power, float distance)
{/*
    float a = pow(clamp( 1.0 - pow(distance/radius, 4.0), 0.0, 200.0), 2.0);
    float b = (pow(distance, 2.0) + 1.0);
    return a/b;*/
    //return radius * (1.0 / (distance*distance));
    return power / (4.0f * PI * (distance*distance));
}