#version 400 core

// Interpolated values from the vertex shaders
in vec2 UV;
in vec3 Normal;
in vec3 FragPos;
in vec3 oTBN;
uniform bool normal;
uniform bool flashLight;

// Ouput data
out vec4 color;

uniform sampler2D texture_diffuse;
uniform sampler2D texture_specular;
uniform sampler2D texture_normal;
uniform sampler2D texture_height;
uniform samplerCube skybox;

uniform bool parallax;

in VS_OUT
{
    vec3 FragPos;
    vec3 Normal;
    vec2 UV;
} fs_in;

struct PointLight
{
    vec3 position;

    float constant;
    float linear;
    float quadratic;

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

#define NR_POINT_LIGHTS 4
in vec3 TangentLightPos[NR_POINT_LIGHTS];
in vec3 TangentViewPos;
in vec3 TangentViewDir;
in vec3 TangentFragPos;
in vec3 TangentLightdir;
in float visibility;

in vec3 cubeCoords;

uniform PointLight pointLights[NR_POINT_LIGHTS];
uniform vec3 viewPos;
uniform vec3 viewDir;
uniform float cut;
uniform float cutoff;
uniform float time;
uniform float plane;
uniform int clip_Direction;
uniform bool BelowWater;
in vec3 TangentNormal;
uniform vec3 LightDirection;


vec3 calculatePoint(int index, float lightpower, vec2 texCoords);
vec3 FlashLight();
vec3 CalculateDirectional(vec2 texCoords);
vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir);

vec3 imageNormal;
bool blinn = flashLight;
vec4 SkyColor;
void main()
{
/** Harcoded Cliping plane*/

/** Refraction*/

if(clip_Direction == 1)
{
	if(BelowWater == false)
	{
				if(fs_in.FragPos.y > plane){
					discard;}
	}
	if(BelowWater == true)
	{
				if(fs_in.FragPos.y < plane){
					discard;}
	}
}
/** Reflection*/
if(clip_Direction == -1)
{
		if(!BelowWater)
		{
				if(fs_in.FragPos.y < plane){
						discard;}
		}
		if(BelowWater)
		{
			discard;
		}
}


    //float lightpower = clamp( (sin(time / 3) * 5) * (cos(time / 3) * 5) * 2, 1, 8);
    float lightpower = 5;

    vec3 viewDirection = normalize(TangentViewPos - TangentFragPos);

    vec2 texcoord = fs_in.UV;
    if(parallax == true && length(viewPos - fs_in.FragPos) < 15)
        texcoord = ParallaxMapping(texcoord, viewDirection);

      if(texture(texture_diffuse, texcoord).a < 0.05)
        discard;
/*
    if(texcoord.x > 1.0 || texcoord.y > 1.0 || texcoord.x < 0.0 || texcoord.y < 0.0)
        discard;*/

    vec3 result = vec3(0);
    if(normal)
    imageNormal = normalize(texture(texture_normal, texcoord).rgb * 2 - 1);
    else
    imageNormal = fs_in.Normal;

    //vec3 I = normalize(fs_in.FragPos - viewPos);
    //vec3 R = reflect(I, mix(fs_in.Normal, -imageNormal , 0.04));
    SkyColor = texture(skybox, cubeCoords);

    result += CalculateDirectional(texcoord);

    //for(int i = 0 ; i < NR_POINT_LIGHTS ; i++)
    //    result += calculatePoint(i,  lightpower, texcoord);

    if(flashLight)
        result += FlashLight();

    color = vec4( mix(vec3(0.5, 0.5, 0.5), result, visibility), 1.0);
}

vec3 CalculateDirectional(vec2 texCoords)
{
    vec3 lightdirection;
    vec3 viewDir;
    float diff;
    vec3 lightDir;
    vec3 specular;
    vec3 norm;
    vec3 ambient = vec3(texture(texture_diffuse, texCoords)) *  (SkyColor.rgb*0.2);
    vec3 lightcolor = normalize(vec3(250, 190, 108));

    if(normal)
    {
        norm = normalize(texture(texture_normal, texCoords).rgb * 2 - 1);
        lightDir = TangentLightdir;
        diff = max(dot(lightDir, norm), 0.0);
        viewDir = normalize(TangentViewPos - TangentFragPos);
    }
    else
    {
        lightdirection = vec3(0.0, -0.8, -0.5);
        viewDir = normalize(viewPos - fs_in.FragPos);
        norm = normalize(fs_in.Normal);
        lightDir = normalize(LightDirection);
        diff = max(dot(norm, lightDir), 0.0);
    }

    vec3 diffuse =  diff * texture(texture_diffuse, texCoords).rgb;
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(norm, halfwayDir), 0.0),128);
    specular = spec * vec3(0.5) * texture(texture_specular, texCoords).r;

    vec3 reflection = SkyColor.rgb * specular * 2;

    return mix(reflection, (diffuse + reflection + ambient) * lightcolor * 2 , 1.0);
}

vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir)
{
    // number of depth layers
    const float minLayers = 15;
    const float maxLayers = 25;
    float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));
    // calculate the size of each layer
    float layerDepth = 1.0 / numLayers;
    // depth of current layer
    float currentLayerDepth = 0.0;
    // the amount to shift the texture coordinates per layer (from vector P)
    vec2 P = viewDir.xy / viewDir.z * 0.04;
    vec2 deltaTexCoords = P / numLayers;

    // get initial values
    vec2  currentTexCoords     = texCoords;
    float currentDepthMapValue = texture(texture_height, currentTexCoords).r;

    while(currentLayerDepth < currentDepthMapValue)
    {
        // shift texture coordinates along direction of P
        currentTexCoords -= deltaTexCoords;
        // get depthmap value at current texture coordinates
        currentDepthMapValue = texture(texture_height, currentTexCoords).r;
        // get depth of next layer
        currentLayerDepth += layerDepth;
    }

    // -- parallax occlusion mapping interpolation from here on
    // get texture coordinates before collision (reverse operations)
    vec2 prevTexCoords = currentTexCoords + deltaTexCoords;

    // get depth after and before collision for linear interpolation
    float afterDepth  = currentDepthMapValue - currentLayerDepth;
    float beforeDepth = texture(texture_height, prevTexCoords).r - currentLayerDepth + layerDepth;

    // interpolation of texture coordinates
    float weight = afterDepth / (afterDepth - beforeDepth);
    vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);

    return finalTexCoords;
}

vec3 FlashLight()
{
    vec3 ambient = vec3(0.01) * vec3(texture(texture_diffuse, fs_in.UV));

    // Diffuse
    vec3 norm = normalize(fs_in.Normal);
    vec3 lightDir = normalize(viewPos - fs_in.FragPos); //normalize( vec3(viewPos.x -0.005 + sin(time), viewPos.y -0.005 * sin(time), viewPos.z+0.005 * sin(time)) - fs_in.FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = vec3(1) * diff * vec3(texture(texture_diffuse, fs_in.UV));

    // Specular
    vec3 viewDirection = normalize(viewPos - fs_in.FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDirection, reflectDir), 0.0), 32);
    vec3 specular = vec3(1) * spec * vec3(texture(texture_specular, fs_in.UV));

    // Spotlight (soft edges)
    float theta = dot(lightDir, normalize(-viewDir));
    float epsilon = (cut - cutoff);
    float intensity = clamp((theta - cutoff) / epsilon, 0.0, 1.0);
    diffuse  *= intensity;
    specular *= intensity;

    // Attenuation
    float distance    = length(viewPos - fs_in.FragPos);
    float attenuation = 1.0f / distance;//(1 + 0.35 * distance + 10.8 * (distance * distance));
    ambient *= attenuation;
    diffuse *= attenuation;
    specular *= attenuation;

    return vec3(ambient + diffuse*5 + specular*5);

}

vec3 calculatePoint(int index, float lightpower,vec2 texCoords)
{
    vec3 viewDir;
    vec4 diftex = texture(texture_diffuse, texCoords);
    //if(diftex.a < 0.2)
    //discard;
    vec3 lightDir;
    float diff;
    vec3 norm;
    vec3 specular;
    //vec3 lightcolor = vec3(clamp(sin(time*3),0.1, 1), clamp(cos(time*2),0.4, 1), clamp(sin(time*2),0.3, 1));
    vec3 ambient = vec3(0.03) * diftex.rgb ;
    vec3 lightcolor = vec3(1); //normalize(vec3(244, 234, 108));
    float distance;
    if(normal)
    {
        viewDir = normalize(TangentViewPos - TangentFragPos);
        lightDir = normalize(TangentLightPos[index] - TangentFragPos);
        norm = normalize(texture(texture_normal, texCoords).rgb * 2.0 - 1.0);;
        diff = max(dot(lightDir, norm), 0.0);
        distance = length(TangentLightPos[index] - TangentFragPos);
    }
    else
    {
        lightDir = normalize(pointLights[index].position - fs_in.FragPos);
        viewDir = normalize(viewPos - fs_in.FragPos);
        norm = normalize(fs_in.Normal);
        diff = max(dot(norm, lightDir), 0.0);
        distance    = length(pointLights[index].position - fs_in.FragPos);
    }

    vec3 diffuse = normalize(vec3(0.5)) * diff * diftex.rgb;

    //float attenuation = 1.0f / (1.0 + 0.35 * distance + 1.8 * (distance*distance));
    float attenuation = 0;
    //attenuation = 1.0f / (1.0 + 0.35 * distance + 1.8 * (distance*distance));
    attenuation = 1.0f /  (distance) ;

    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(norm, halfwayDir), 0.0),64);
    specular = vec3(0.5) * spec * texture(texture_specular, texCoords).r;
    diffuse  *= attenuation;
    specular *= attenuation;

    return  (diffuse + specular*3 + ambient) * lightpower* lightcolor;
}
