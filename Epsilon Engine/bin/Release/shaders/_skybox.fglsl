#version 440 core


layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 blurImage;
layout(location = 2) out vec4 gDepth;
layout(location = 3) out vec4 gExtraComponents; 
layout(location = 4) out vec3 gLightAccumulation;

#define Scale vec3(0.3, 0.1, 0.1)
#define K 19.19

in vec3 FragPos;

uniform float time;
uniform vec3 LightDirection;

const vec3 Blue = normalize(vec3(29,91,186));
const vec3 Cian = normalize(vec3(125, 228, 247));
const vec3 Orange = normalize(vec3(224,115,36));
const vec3 Gray = normalize(vec3(0.001,0.001,0.001));
const vec3 Black = normalize(vec3(0.0,0.0,0.0));
const vec3 Brown = normalize(vec3(123.0,91.0,68.0));
const vec3 DarkRootwood = normalize(vec3(43, 52, 81));

const float lowerlimit = 0.0;
const float upperlimit = 0.03;

uniform mat4 projection;
uniform mat4 view;
uniform bool state;
in vec3 Normal;

vec3 hash(vec3 p3)
{
	p3 = fract(p3 * Scale);
    p3 += dot(p3, p3.yxz+19.19);
    return fract((p3.xxy + p3.yxx)*p3.zyx);

}

vec3 noise( in vec3 x )
{
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
	
    return mix(mix(mix( hash(p+vec3(0,0,0)), 
                        hash(p+vec3(1,0,0)),f.x),
                   mix( hash(p+vec3(0,1,0)), 
                        hash(p+vec3(1,1,0)),f.x),f.y),
               mix(mix( hash(p+vec3(0,0,1)), 
                        hash(p+vec3(1,0,1)),f.x),
                   mix( hash(p+vec3(0,1,1)), 
                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);
}

const mat3 m = mat3( 0.00,  0.80,  0.60,
                    -0.80,  0.36, -0.48,
                    -0.60, -0.48,  0.64 );
vec3 fbm(in vec3 q)
{
            vec3    f  = 0.5000*noise( q ); q = m*q*2.01;
                    f += 0.2500*noise( q ); q = m*q*2.02;
                    f += 0.1250*noise( q ); q = m*q*2.03;
                    f += 0.0625*noise( q ); q = m*q*2.04;  
                    f += 0.03125*noise( q ); q = m*q*2.05; 
                    //f += 0.015625*noise( q ); q = m*q*2.06; 
    return vec3(f);
}

float getAverage(in vec3 color)
{
	return dot(color, vec3(0.2126, 0.7152, 0.0722));
}


void main()
{
	if(!state){
    	vec3 Clouds = fbm(vec3(FragPos.x*4.0+time*0.08, FragPos.y*9.0+time*0.08, FragPos.z*4.0+time*0.08));

    	float scatteringFactor = clamp((FragPos.y - lowerlimit) / (upperlimit - lowerlimit), 0.0, 1.0);

        vec3 SunDir = LightDirection; 

        float Sun = smoothstep(0.95, 1.0, max(dot(-Normal, SunDir), 0.0) * 0.80);

    	vec3 Background = mix(Cian, Blue, clamp(FragPos.y*5.0+0.15, 0.0, 1.0));

        vec3 SkyColor = mix(Orange, Background, scatteringFactor);

    	vec3 TimeColor = mix(Gray, SkyColor, clamp(LightDirection.y, 0.0, 1.0));//DarkRootwood*0.2;

        vec3 MixedClouds = sqrt(vec3(vec3(Clouds.x * 0.2126 + Clouds.y * 0.7152 + Clouds.z * 0.0722)*1.5));

    	vec3 color = mix(TimeColor, MixedClouds, clamp(pow(mix(0.0, Clouds.x*3.0, Clouds.z), 3.0), 0.0, 1.0)) * 0.1 /** clamp(LightDirection.y, 0.1, 0.5)*/;

        vec3 LightColor = normalize(vec3(218, 205, 118));
        float scattering  = max(dot(FragPos, LightDirection), 0.0);
    	FragColor.rgb = color*1.1/*+(scattering*0.5)*/ /** max(0.1, LightDirection.y+0.2) */;
        FragColor.a = 1.0;


        blurImage = (vec4(FragColor)*0.15) /*+ vec4(sun*2.0*LightColor, 1.0)*/;
        blurImage.a = 1.0;
        //gExpensiveNormal.rgb = vec3(0.0);
        
        gDepth = vec4(vec3(1.0), 1.0);
        gLightAccumulation = vec3(1.0);
        gExtraComponents = vec4(0.0);

    } else {
        FragColor.rgb = vec3(1.0);
        FragColor.a = 1.0;


        blurImage = vec4(1.0);
        //gExpensiveNormal.rgb = vec3(0.0);
        
        gDepth = vec4(vec3(1.0), 1.0);
        gLightAccumulation = vec3(1.0);
        gExtraComponents = vec4(0.0);
    }
}