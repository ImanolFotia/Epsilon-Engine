#version 400 core

uniform sampler2D gFinalImage;
uniform sampler2D gPosition;
uniform sampler2D gNormal;
uniform sampler2D gExtraComponents;
uniform sampler2D ColorBuffer; 
noperspective in vec2 TexCoords;

out vec4 outColor;

uniform mat4 invView;
uniform mat4 projection;
uniform mat4 invprojection;
uniform vec2 Resolution;
uniform mat4 view;
// Consts should help improve performance
/*
const float rayStep = 0.05;
const float minRayStep = 0.1;
const float maxSteps = 50;
const float searchDist = 5;
const float searchDistInv = 0.2;
const int numBinarySearchSteps = 5;
const float maxDDepth = 1.0;
const float maxDDepthInv = 1.0;
 */

const float rayStep = 0.05;
const float minRayStep = 0.1;
const float maxSteps = 60;
const float searchDist = 5;
const float searchDistInv = 0.2;
const int numBinarySearchSteps = 5;
const float maxDDepth = 1.0;
const float maxDDepthInv = 1.0;
 
const float reflectionSpecularFalloffExponent = 3.0;
float specular;

vec3 PositionFromDepth(float depth) {
    float z = depth * 2.0 - 1.0;

    vec4 clipSpacePosition = vec4(TexCoords * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = invprojection * clipSpacePosition;

    // Perspective division
    viewSpacePosition /= viewSpacePosition.w;

    return viewSpacePosition.xyz;
}

float NEAR = 0.1;
float FAR = 3000.0;

float LinearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0; // Back to NDC
    return ((2.0 * NEAR * FAR) / (FAR + NEAR - z * (FAR - NEAR)));
}

vec3 BinarySearch(inout vec3 dir, inout vec3 hitCoord, inout float dDepth)
{
    float depth;

        vec4 projectedCoord;
 
    for(int i = 0; i < numBinarySearchSteps; i++)
    {

    	projectedCoord = projection * vec4(hitCoord, 1.0);
        projectedCoord.xy /= projectedCoord.w;
        projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;
 
 
        //depth = PositionFromDepth( texture(gDepth, projectedCoord.xy, 3).r).z;
        depth = textureLod(gPosition, projectedCoord.xy, 2).z;

 
        dDepth = hitCoord.z - depth;

        if(dDepth > 0.0)
            hitCoord += dir;
 
        dir *= 0.5;
        hitCoord -= dir;    
    }


    	projectedCoord = projection * vec4(hitCoord, 1.0);
        projectedCoord.xy /= projectedCoord.w;
        projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;
 
    return vec3(projectedCoord.xy, depth);
}
 
 
vec4 RayCast(vec3 dir, inout vec3 hitCoord, out float dDepth)
{

	//if(specular*0.5 < 0.1)
	//	return vec4(0.0, 1.0, 0.0, 1.0);


    dir *= rayStep;
 
 
    float depth;
    int steps;
 vec4 projectedCoord;

 
    for(int i = 0; i < maxSteps; i++)
    {
        hitCoord += dir;
 
        projectedCoord = projection * vec4(hitCoord, 1.0);
        projectedCoord.xy /= projectedCoord.w;
        projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;
 
        //depth = PositionFromDepth( texture(gDepth, projectedCoord.xy, 3).r).z;
        depth = textureLod(gPosition, projectedCoord.xy, 2).z;
        if(depth > 1000.0)
            continue;
 
        dDepth = hitCoord.z - depth;

        if((dir.z - dDepth) < 0.2)
        if(dDepth <= 0.0)
        {	
        	vec4 asd;
            	asd = vec4(BinarySearch(dir, hitCoord, dDepth), 1.0);

        	//if(dir.z <= dDepth)
            	return asd;
        }
    	
        steps++;
    }
 
 	
    return vec4(0.0);//vec4(projectedCoord.xy, depth, 0.0);
}


vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float hash( in vec3 x ) {
    float n = dot( x, vec3(1.0,113.0,257.0) );
    return fract(sin(n)*43758.5453);
}

#define HASHSCALE3 vec3(.8, .8, .8)
vec3 hash33(vec3 p3)
{
    p3 = fract(p3 * HASHSCALE3);
    p3 += dot(p3, p3.yxz+19.19);
    return fract((p3.xxy + p3.yxx)*p3.zyx);

}

void main()
{

	vec2 gTexCoord = gl_FragCoord.xy/vec2(Resolution);
	//vec2 gTexCoord2 = gl_FragCoord.xy/vec2(Resolution2);
	//gTexCoord *= 2 - 1;
	//gTexCoord.x *= Resolution.x / Resolution.y;
 
    // Samples
    vec2 extra = texture2D(gExtraComponents, TexCoords).rg;
    specular = extra.r;

    if(specular < 0.01)
    	discard;
 
    vec3 viewNormal = vec3(texture2D(gNormal, TexCoords) * invView);
    //vec3 viewPos = PositionFromDepth(texture(gDepth, TexCoords).r).xyz;
    vec3 viewPos = textureLod(gPosition, TexCoords, 2).xyz;
    vec3 albedo = texture(gFinalImage, TexCoords).rgb;
    float spec = texture(ColorBuffer, TexCoords).w;

    vec3 F0 = vec3(0.04); 
    F0      = mix(F0, albedo, specular);
    vec3 F = fresnelSchlickRoughness(max(dot(normalize(viewNormal), normalize(viewPos)), 0.0), F0);
    // Reflection vector
    vec3 reflected = normalize(reflect(normalize(viewPos), normalize(viewNormal)));


    // Ray cast
    vec3 hitPos = viewPos;
    float dDepth;
 
    //vec3 irradiance = texture(gLightAccumulation, TexCoords).rgb;
    vec3 wp = vec3(vec4(viewPos, 1.0) * invView);
    vec3 jitt = mix(vec3(0.0), vec3(hash33(wp)), spec);
    vec4 coords = RayCast((vec3(jitt) + reflected * max(minRayStep, -viewPos.z)), hitPos, dDepth);
 
 
    vec2 dCoords = smoothstep(0.2, 0.6, abs(vec2(0.5, 0.5) - coords.xy));
 
 
    float screenEdgefactor = clamp(1.0 - (dCoords.x + dCoords.y), 0.0, 1.0);

    float asd = pow(specular, reflectionSpecularFalloffExponent) * 
    			screenEdgefactor * 
    			-reflected.z;
 
    // Get color
    vec3 SSR = textureLod(gFinalImage, coords.xy, 0).rgb * clamp(asd, 0.0, 0.9);  //specular * 0.5 * screenEdgefactor
    //vec3 SSR = vec3(screenSpaceReflection());
    //if(asd < .01)
    //    SSR = irradiance;
	outColor = vec4(SSR, specular);//vec4(clamp(-reflected.z, 0.0, 1.0), coords.y, coords.z, clamp(-reflected.z, 0.0, 1.0));
    //outColor = outColor / (outColor + vec4(1.0)); 
}