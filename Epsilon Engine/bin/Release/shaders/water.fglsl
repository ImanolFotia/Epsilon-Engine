#version 330 core

in vec2 TexCoords;
in vec4 clipSpace;;
in vec3 viewDir;
in float visibility;
in vec3 FragPos;
in vec3 wFragPos;
in mat3 viewMatrix;
in mat3 TBN;
uniform sampler2D reflectionSampler;
uniform sampler2D refractionSampler;
uniform sampler2D normalSampler;
uniform sampler2D DuDvSampler;
uniform sampler2D depthSampler;
uniform sampler2D foamSampler;
uniform sampler2D diffuseSampler;

uniform vec3 LightDirection;

uniform vec3 cameraDirection;
uniform float time;


layout(location = 0) out vec4 gAlbedoSpec;
layout(location = 1) out vec3 gNormal;
layout(location = 2) out vec4 gPosition;
layout(location = 3) out vec3 gExpensiveNormal;
layout(location = 4) out vec3 gWorldSpacePosition;

vec4 SkyColor = vec4(0.5,0.5,0.5, 1.0);
vec3 NightFog = vec3(0.1,0.1,0.1);
    vec3 lightcolor = normalize(vec3(250, 190, 108));

    const float density = 0.005;
    const float gradient = 3.5;

uniform mat4 view;
uniform mat4 model;

vec3 T;
vec3 B;
vec3 N;


    vec3 tangent;
    vec3 binormal;
    vec3 normal;
mat3 CreateTBNMatrix(mat3 normalMatrix)
{
     T = normalize(normalMatrix * tangent);
     B = normalize(normalMatrix * binormal);
     N = normalize(normalMatrix * vec3(0,1,0));

    return transpose(mat3(T, B, N));
}

void main()
{
    float moveFactor = 0.002 * time;
    float distStrenght =  0.009;

    vec2 normalizedDeviceCoordinates = (clipSpace.xy / clipSpace.w) / 2.0 + 0.5;

    vec2 refracCoords = vec2(normalizedDeviceCoordinates.x, normalizedDeviceCoordinates.y );
    vec2 reflecCoords = vec2(normalizedDeviceCoordinates.x, -normalizedDeviceCoordinates.y);

    vec2 distortion1 = (texture(DuDvSampler,vec2(TexCoords.x + moveFactor - moveFactor + 5, TexCoords.y - moveFactor)).rg * 2.0 - 1.0) * distStrenght;
    vec2 distortion2 = (texture(DuDvSampler,vec2(TexCoords.x + moveFactor + moveFactor, TexCoords.y + moveFactor - 5)).rg * 2.0 - 1.0) * distStrenght;
    vec2 finalDist = distortion1 + distortion2;

    float near = 0.1;
    float far = 3000.0f;
    float depth = texture(depthSampler, refracCoords).r;
    float floorDistance = 2.0 * near * far / (far + near - (2.0 * depth - 1.0) * (far - near));

    depth = gl_FragCoord.z;
    float waterDistance = 2.0 * near * far / (far + near - (2.0 * depth - 1.0) * (far - near));
    float waterDepth = floorDistance - waterDistance;

    refracCoords += finalDist;
    refracCoords = clamp(refracCoords, 0.001, 0.999);

    reflecCoords += finalDist;
    reflecCoords.x = clamp(reflecCoords.x, 0.001, 0.999);
    reflecCoords.y = clamp(reflecCoords.y, -0.999, -0.001);

    vec4 refractiontex = texture(refractionSampler, refracCoords);
    vec4 reflectiontex =  texture(reflectionSampler, reflecCoords);

    vec3 viewVector = normalize(viewDir);
    if(viewVector.y < 0.0)
    viewVector.y = -1 * viewVector.y;

    vec4 normaltex = texture(normalSampler, finalDist);
    normal = vec3(normaltex.r, normaltex.b*3.0, normaltex.g) * 2 - 1;
    normal = normalize(normal);

    float refractiveFactor = dot(viewVector, vec3(0,1,0));
    refractiveFactor = clamp(refractiveFactor, 0.0, 1.0);

    vec4 foamTexture = texture(foamSampler,TexCoords + moveFactor);

    //gAlbedoSpec.rgb = mix(reflectiontex, refractiontex , min(refractiveFactor, clamp(waterDepth/5, 0.0, 1.0))).rgb;
    //gAlbedoSpec.rgb = mix(refractiontex.rgb, gAlbedoSpec.rgb, clamp(waterDepth/5, 0.0, 1.0));
    //gAlbedoSpec.rgb = mix(texture(diffuseSampler, finalDist).rgb, gAlbedoSpec.rgb, 0.8);
    gAlbedoSpec.rgb = vec3(0.0);//texture(diffuseSampler, finalDist).rgb;
    gAlbedoSpec.a = 1.0;
    gExpensiveNormal = normal;

    normal = vec3(normaltex.r, normaltex.b*4.0, normaltex.g);

    gNormal = normalize(vec3(0,1,0) * TBN);//normalize(normal * mat3(view) /* TBN*/);
    gPosition.rgb = FragPos;
    gPosition.a = 1000000000;
    gWorldSpacePosition = wFragPos;
/*
    FragColor = mix(FragColor, vec4(specular * lightcolor, 1.0), 0.5);
    //FragColor = mix(foamTexture, FragColor, clamp(waterDepth/0.2, 0.0, 1.0));
      float  visibility = exp(-pow((waterDistance*density), gradient));
      	SkyColor = mix(normalize(vec4(250, 190, 108, 1.0)), SkyColor, abs(LightDirection.y)+0.2);
        	vec3 fogColor = mix(NightFog, SkyColor.rgb, clamp(LightDirection.y + 1, 0.0, 1.0));
      FragColor = mix(vec4(fogColor, 1.0), FragColor, visibility );
    FragColor.a = max(clamp(waterDepth/4.0, 0.0, 1.0), 0.1);
*/


}
