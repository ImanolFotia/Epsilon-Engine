#version 430 core


layout(location = 0) out vec4 gAlbedoSpec;
layout(location = 1) out vec3 gPosition;
layout(location = 2) out vec3 gExpensiveNormal;
layout(location = 3) out float gDepth;
layout(location = 4) out vec4 gExtraComponents; 

in vec2 TexCoords;
in vec4 clipSpace;;
in vec3 viewDir;
in float visibility;
in vec3 FragPos;
in vec3 wFragPos;
in mat3 TBN;
in mat3 TBN2;

layout (binding = 0) uniform sampler2D ColorBuffer;
layout (binding = 1) uniform sampler2D normalSampler;
layout (binding = 2) uniform sampler2D DuDvSampler;
layout (binding = 3) uniform sampler2D diffuseSampler;

uniform float time;

vec4 SkyColor = vec4(0.5,0.5,0.5, 1.0);
vec3 NightFog = vec3(0.1,0.1,0.1);
    vec3 lightcolor = normalize(vec3(250, 190, 108));

    const float density = 0.003;
    const float gradient = 1.5;

in vec3 Normal;

vec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), 
                                              2.0+dot(p,vec2(11.0,47.0)),
                                              3.0+dot(p,vec2(41.0,29.0)),
                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }

vec4 textureNoTile( sampler2D samp, in vec2 uv )
{
    ivec2 iuv = ivec2( floor( uv ) );
     vec2 fuv = fract( uv );

    // generate per-tile transform
    vec4 ofa = hash4( iuv + ivec2(0,0) );
    vec4 ofb = hash4( iuv + ivec2(1,0) );
    vec4 ofc = hash4( iuv + ivec2(0,1) );
    vec4 ofd = hash4( iuv + ivec2(1,1) );
    
    vec2 ddx = dFdx( uv );
    vec2 ddy = dFdy( uv );

    // transform per-tile uvs
    ofa.zw = sign( ofa.zw-0.5 );
    ofb.zw = sign( ofb.zw-0.5 );
    ofc.zw = sign( ofc.zw-0.5 );
    ofd.zw = sign( ofd.zw-0.5 );
    
    // uv's, and derivatives (for correct mipmapping)
    vec2 uva = uv*ofa.zw + ofa.xy, ddxa = ddx*ofa.zw, ddya = ddy*ofa.zw;
    vec2 uvb = uv*ofb.zw + ofb.xy, ddxb = ddx*ofb.zw, ddyb = ddy*ofb.zw;
    vec2 uvc = uv*ofc.zw + ofc.xy, ddxc = ddx*ofc.zw, ddyc = ddy*ofc.zw;
    vec2 uvd = uv*ofd.zw + ofd.xy, ddxd = ddx*ofd.zw, ddyd = ddy*ofd.zw;
        
    // fetch and blend
    vec2 b = smoothstep( 0.25,0.75, fuv );
    
    return mix( mix( textureGrad( samp, uva, ddxa, ddya ), 
                     textureGrad( samp, uvb, ddxb, ddyb ), b.x ), 
                mix( textureGrad( samp, uvc, ddxc, ddyc ),
                     textureGrad( samp, uvd, ddxd, ddyd ), b.x), b.y );
}

void main()
{
    float moveFactor = 0.004 * time;
    float distStrenght =  0.009;
    vec2 normalizedDeviceCoordinates = (clipSpace.xy / clipSpace.w) * 0.5 + 0.5;
    vec2 refracCoords = vec2(normalizedDeviceCoordinates.x, normalizedDeviceCoordinates.y );
    vec4 normaltex = texture(normalSampler, TexCoords - moveFactor);
    normaltex = (normaltex * 2.0 - 1.0);

    //refracCoords += vec2(normaltex.x, normaltex.z);
    //refracCoords = clamp(refracCoords, 0.001, 0.999);


    gAlbedoSpec.rgb = texture(diffuseSampler, TexCoords - moveFactor).rgb;
    gAlbedoSpec.a = 1.0;
    gExpensiveNormal.rgb = normalize(normaltex.rgb * TBN);

    gPosition.rgb = FragPos;
    gDepth = gl_FragCoord.z;

    gExtraComponents = vec4(1.0, 0.0, 0.0, 0.0);


}
