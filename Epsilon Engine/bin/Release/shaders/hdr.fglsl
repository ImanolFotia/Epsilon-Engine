#version 330 core

uniform sampler2D sampler;
uniform sampler2D blurredSampler;
uniform sampler1D uLensColor;
uniform sampler2D uLensDirtTex;
uniform sampler2D uLensStarTex;
uniform sampler2D gReflectionSampler;
uniform sampler2D brightColorBuffer;
uniform sampler2D MotionBlurSampler;
uniform float time;
out vec4 color;
noperspective in vec2 TexCoords;
uniform float exposure;
uniform mat4 choppedView;
uniform mat4 projection;
uniform vec3 sunPos;
uniform bool lightShafts;
const float gamma = 2.2;
const float contrast = 0.1;

uniform vec2 Resolution;

   int uGhosts = 5; // number of ghost samples
   float uGhostDispersal = 0.3f; // dispersion factor
   float uHaloWidth = 10;
 float uDistortion = 5;

vec3 HDR(vec3 image)
{
    vec3 result = vec3(1.0) - exp(-image.xyz * exposure);
    result.xyz = pow(result.xyz, vec3(1.0 / gamma));
    return (result.xyz - 0.5f) * (1.0 + contrast) + 0.5f;
}

float A = 0.15;
float B = 0.50;
float C = 0.10;
float D = 0.20;
float E = 0.02;
float F = 0.30;
float W = 11.2;

vec3 Uncharted2Tonemap(vec3 x)
{
   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

vec3 HDR2(vec3 image)
{
    float ExposureBias = 2.0f;
    image*= exposure;
   vec3 curr = Uncharted2Tonemap(ExposureBias*image);

   vec3 whiteScale = 1.0f/Uncharted2Tonemap(vec3(W));
   vec3 color = curr*whiteScale;
      
   vec3 result = pow(color,vec3(1.0/gamma));
   return (result.xyz - 0.5f) * (1.0 + contrast) + 0.5f;
}

/*----------------------------------------------------------------------------*/
vec4 textureDistorted(
    in sampler2D tex, 
    in vec2 texcoord, 
    in vec2 direction,
    in vec3 distortion 
) {
    return vec4(
        texture(tex, texcoord + direction * distortion.r).r,
        texture(tex, texcoord + direction * distortion.g).g,
        texture(tex, texcoord + direction * distortion.b).b,
        1.0
    );
}

/*----------------------------------------------------------------------------*/

float hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }

vec3 lOff(){    
    
    vec2 u = vec2(1.0, 0.0);
    mat2 a = mat2(u, -u.y, u.x);
    
    vec3 l = normalize(vec3(1.5, 1., -0.5));
    l.xz = a * l.xz;
    l.xy = a * l.xy;
    
    return l;
    
}

vec3 changeSaturation(vec3 color, float saturation)
{
    float luma = dot(vec3(0.213, 0.715, 0.072) * color, vec3(1.));
    return mix(vec3(luma), color, saturation);
}
    // Radial blur factors.
    //
    // Falloff, as we radiate outwards.
    float decay = 0.97; 
    // Controls the sample density, which in turn, controls the sample spread.
    float density = 1.0; 
    // Sample weight. Decays as we radiate outwards.
    float weight = 0.3; 
const float SAMPLES = 20.; 

void main()
{

    vec2 texcoord = -TexCoords + vec2(1.0);
    vec2 texelSize = 1.0 / vec2(textureSize(blurredSampler, 0));
   // ghost vector to image centre:
    vec2 ghostVec = (vec2(0.5) - texcoord) * uGhostDispersal;
    vec2 haloVec = normalize(ghostVec) * uHaloWidth;
    vec3 distortion = vec3(-texelSize.x * uDistortion, 0.0, texelSize.x * uDistortion);
   
   // sample ghosts:  
      vec4 result = vec4(0.0);
      for (int i = 0; i < uGhosts; ++i) { 
        vec2 offset = fract(texcoord + ghostVec * float(i));
        float weight = length(vec2(0.5) - offset) / length(vec2(0.5));
        weight = pow(1.0 - weight, 10.0);
  
        result += texture(blurredSampler, offset);
      }
      result *= texture(uLensColor, length(vec2(0.5) - texcoord) / length(vec2(0.5)));

    vec4 lensMod = texture(uLensDirtTex, TexCoords);
    lensMod += texture(uLensStarTex, TexCoords);

    vec3 hdrColor = texture(sampler, TexCoords).rgb;
    vec4 SSR = texture(gReflectionSampler, TexCoords);
    vec3 bloom = texture(blurredSampler, TexCoords).rgb;
    vec3 mb = texture(MotionBlurSampler, TexCoords).rgb;

    vec2 fragcoord = gl_FragCoord.xy/Resolution;

    // Light offset. Kind of fake. See above.
    vec4 col = vec4(0.0);
    vec4 LightColor = vec4(218, 205, 118, 1.0);
    vec4 pos = projection * choppedView * vec4(sunPos, 1.0f);
    if(pos.x > 1.0 || pos.x < -1.0 || pos.y > 1.0 || pos.y < -1.0 || pos.z < 0.0 || sunPos.y < 0.0 || !lightShafts){ col = vec4(0.0);} else{
    vec3 l = vec3(pos.xy, 1.0);//lOff();
    vec2 tuv =  fragcoord - .5 - l.xy*.45;
    vec2 dTuv = tuv*density/SAMPLES;
    col = texture(brightColorBuffer, fragcoord.xy)*0.25;
    fragcoord += dTuv*(hash(fragcoord.xy));

       for(float i=0.; i < SAMPLES; i++){
    
        fragcoord -= dTuv;
        col += texture2D(brightColorBuffer, fragcoord) * weight;
        weight *= decay;
        
    }
    col *= (1. - dot(tuv, tuv)*.75);
    col = smoothstep(0., 1., col);
}

    col = mix(col, vec4(0.0), length(vec2(0.0) - pos.xy));
    col = vec4(clamp(col.x, 0.0, 1.0), clamp(col.y, 0.0, 1.0), clamp(col.z, 0.0, 1.0), col.w) * 0.25 * normalize(vec4(205, 109, 39, 1.0));

    fragcoord = gl_FragCoord.xy/Resolution;
    float vignete = 1.0 - smoothstep(0.9, 1.75, length(vec2(0.0) - (fragcoord * 2.0 - 1.0)));

    //hdrColor = changeSaturation(hdrColor, .3);

    color.rgb  = (HDR2((hdrColor + col.rgb + bloom + (result.rgb * lensMod.rgb*5)+ clamp(SSR.rgb, 0.0, 1.0) )  )) * vignete;

    

    color.a = 1.0;

}