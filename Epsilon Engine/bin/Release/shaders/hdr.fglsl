#version 330 core

uniform sampler2D sampler;
uniform sampler2D blurredSampler;
uniform sampler1D uLensColor;
uniform sampler2D uLensDirtTex;
uniform sampler2D uLensStarTex;
uniform sampler2D gReflectionSampler;
uniform float time;
out vec4 color;
noperspective in vec2 TexCoords;
uniform float exposure;
uniform mat4 choppedView;
uniform mat4 projection;
uniform vec3 sunPos;
uniform bool lightShafts;
const float gamma = 2.2;
const float contrast = 0.3;

uniform vec2 Resolution;

   int uGhosts = 5; // number of ghost samples
   float uGhostDispersal = 0.3f; // dispersion factor
   float uHaloWidth = 10;
 float uDistortion = 5;

vec3 HDR(vec3 image)
{
    vec3 result = vec3(1.0) - exp(-image.xyz * exposure);
    result.xyz = pow(result.xyz, vec3(1.0 / gamma));
    return (result.xyz - 0.5f) * (1.0 + contrast) + 0.5f;
}

/*----------------------------------------------------------------------------*/
vec4 textureDistorted(
	in sampler2D tex, 
	in vec2 texcoord, 
	in vec2 direction,
	in vec3 distortion 
) {
	return vec4(
		texture(tex, texcoord + direction * distortion.r).r,
		texture(tex, texcoord + direction * distortion.g).g,
		texture(tex, texcoord + direction * distortion.b).b,
		1.0
	);
}

/*----------------------------------------------------------------------------*/

float hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }

vec3 lOff(){    
    
    vec2 u = vec2(1.0, 0.0);
    mat2 a = mat2(u, -u.y, u.x);
    
    vec3 l = normalize(vec3(1.5, 1., -0.5));
    l.xz = a * l.xz;
    l.xy = a * l.xy;
    
    return l;
    
}

vec3 changeSaturation(vec3 color, float saturation)
{
    float luma = dot(vec3(0.213, 0.715, 0.072) * color, vec3(1.));
    return mix(vec3(luma), color, saturation);
}
    // Radial blur factors.
    //
    // Falloff, as we radiate outwards.
    float decay = 0.97; 
    // Controls the sample density, which in turn, controls the sample spread.
    float density = 0.5; 
    // Sample weight. Decays as we radiate outwards.
    float weight = 0.2; 
const float SAMPLES = 20.; 

void main()
{

	vec2 texcoord = -TexCoords + vec2(1.0);
    vec2 texelSize = 1.0 / vec2(textureSize(blurredSampler, 0));
   // ghost vector to image centre:
    vec2 ghostVec = (vec2(0.5) - texcoord) * uGhostDispersal;
	vec2 haloVec = normalize(ghostVec) * uHaloWidth;
	vec3 distortion = vec3(-texelSize.x * uDistortion, 0.0, texelSize.x * uDistortion);
   
   // sample ghosts:  
      vec4 result = vec4(0.0);
      for (int i = 0; i < uGhosts; ++i) { 
        vec2 offset = fract(texcoord + ghostVec * float(i));
        float weight = length(vec2(0.5) - offset) / length(vec2(0.5));
      	weight = pow(1.0 - weight, 10.0);
  
        result += texture(blurredSampler, offset);
      }
      result *= texture(uLensColor, length(vec2(0.5) - texcoord) / length(vec2(0.5)));

	vec4 lensMod = texture(uLensDirtTex, TexCoords);
	lensMod += texture(uLensStarTex, TexCoords);

    vec3 hdrColor = texture(sampler, TexCoords, 0.0).rgb;
    vec3 SSR = texture(gReflectionSampler, TexCoords).rgb;
    vec3 bloom = texture(blurredSampler, TexCoords).rgb;


    vec2 fragcoord = gl_FragCoord.xy/Resolution;

    // Light offset. Kind of fake. See above.
    vec4 col = vec4(0.0);
    vec4 LightColor = vec4(218, 205, 118, 1.0);
	vec4 pos = projection * choppedView * vec4(sunPos, 1.0f);
	if(pos.x > 1.0 || pos.x < -1.0 || pos.y > 1.0 || pos.y < -1.0 || pos.z < 0.0 || sunPos.y < 0.0 || !lightShafts){ col = vec4(0.0);} else{
    vec3 l = vec3(pos.xy, 1.0);//lOff();
    vec2 tuv =  fragcoord - .5 - l.xy*.45;
    vec2 dTuv = tuv*density/SAMPLES;
    col = texture(sampler, fragcoord.xy)*0.25;
    fragcoord += dTuv*(hash(fragcoord.xy));

       for(float i=0.; i < SAMPLES; i++){
    
        fragcoord -= dTuv;
        col += texture2D(sampler, fragcoord) * weight;
        weight *= decay;
        
    }
    col *= (1. - dot(tuv, tuv)*.75);
    col = smoothstep(0., 1., col);
}

    col = mix(col, vec4(0.0), length(vec2(0.0) - pos.xy));
    col = vec4(clamp(col.x, 0.0, 1.0), clamp(col.y, 0.0, 1.0), clamp(col.z, 0.0, 1.0), col.w) * 0.25 /** normalize(vec4(205, 109, 39, 1.0))*/;

	fragcoord = gl_FragCoord.xy/Resolution;
    float vignete = 1.0 - smoothstep(0.9, 1.75, length(vec2(0.0) - (fragcoord * 2.0 - 1.0)));

    //hdrColor = changeSaturation(hdrColor, 0.7);

    color.rgb  = HDR((hdrColor + col.rgb + bloom + (result.rgb * lensMod.rgb*5) ) + SSR*0.3 ) * vignete;

    

    color.a = 1.0;

}


