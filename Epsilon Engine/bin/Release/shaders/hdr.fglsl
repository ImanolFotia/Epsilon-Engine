#version 330 core

uniform sampler2D sampler;
uniform sampler2D blurredSampler;
uniform sampler1D uLensColor;
uniform sampler2D uLensDirtTex;
uniform sampler2D uLensStarTex;
uniform sampler2D gReflectionSampler;
uniform sampler2D brightColorBuffer;
uniform sampler2D MotionBlurSampler;
uniform float time;
out vec4 color;
noperspective in vec2 TexCoords;
uniform float exposure;
uniform mat4 choppedView;
uniform mat4 projection;
uniform vec3 sunPos;
uniform bool lightShafts;
const float gamma = 2.2;
const float contrast = 0.1;

uniform vec2 Resolution;

   int uGhosts = 5; // number of ghost samples
   float uGhostDispersal = 0.3f; // dispersion factor
   float uHaloWidth = 10;
 float uDistortion = 5;

vec3 HDR(vec3 image)
{
    vec3 result = vec3(1.0) - exp(-image.xyz * exposure);
    result.xyz = pow(result.xyz, vec3(1.0 / gamma));
    return (result.xyz - 0.5f) * (1.0 + contrast) + 0.5f;
}

float A = 0.15;
float B = 0.50;
float C = 0.10;
float D = 0.20;
float E = 0.02;
float F = 0.30;
float W = 11.2;

vec3 Uncharted2Tonemap(vec3 x)
{
   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

vec3 HDR2(vec3 image)
{
    float ExposureBias = 2.0f;
    image*= exposure;
   vec3 curr = Uncharted2Tonemap(ExposureBias*image);

   vec3 whiteScale = 1.0f/Uncharted2Tonemap(vec3(W));
   vec3 color = curr*whiteScale;
      
   vec3 result = pow(color,vec3(1.0/gamma));
   return (result.xyz - 0.5f) * (1.0 + contrast) + 0.5f;
}

/*----------------------------------------------------------------------------*/
vec4 textureDistorted(
    in sampler2D tex, 
    in vec2 texcoord, 
    in vec2 direction,
    in vec3 distortion 
) {
    return vec4(
        texture(tex, texcoord + direction * distortion.r).r,
        texture(tex, texcoord + direction * distortion.g).g,
        texture(tex, texcoord + direction * distortion.b).b,
        1.0
    );
}

/*----------------------------------------------------------------------------*/

float hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }

vec3 lOff(){    
    
    vec2 u = vec2(1.0, 0.0);
    mat2 a = mat2(u, -u.y, u.x);
    
    vec3 l = normalize(vec3(1.5, 1., -0.5));
    l.xz = a * l.xz;
    l.xy = a * l.xy;
    
    return l;
    
}

vec3 changeSaturation(vec3 color, float saturation)
{
    float luma = dot(vec3(0.213, 0.715, 0.072) * color, vec3(1.));
    return mix(vec3(luma), color, saturation);
}
    // Radial blur factors.
    //
    // Falloff, as we radiate outwards.
    float decay = 0.97; 
    // Controls the sample density, which in turn, controls the sample spread.
    float density = 1.0; 
    // Sample weight. Decays as we radiate outwards.
    float weight = 0.1; 
const float SAMPLES = 10.; 

#define PI 3.14159265359

vec3 Bokeh(vec2 uv, float rad, float thres, float mult)
{
    vec3 col = vec3(0.0), res = vec3(0.0);
    float r = 1.0;
    
    vec2 pixelSize = 1.0 / Resolution.xy;
    float i = 0.0;
    for(i = 0.0001; i < PI*2.0; i+=PI*0.0314)
    {       
        r += (1.0/r);
        
        vec2 disk = vec2(sin(i*10.0)*(1.0-r), cos(i*10.0)*(1.0-r)) * rad;
        
        col = texture(sampler, uv + pixelSize * disk, 0.0).rgb;
        
        res += col;
        //res2 += pow(col, vec3(5.0))*30.0;
        
    }
    
    //res = res + res2/(i+0.000001)*.1;
    
    return min(max(res/(i+0.000001)*0.1, 0.000001), 50.0);
    
}

void main()
{

    vec2 texcoord = -TexCoords + vec2(1.0);
    vec2 texelSize = 1.0 / vec2(textureSize(blurredSampler, 0));
   // ghost vector to image centre:
    vec2 ghostVec = (vec2(0.5) - texcoord) * uGhostDispersal;
    vec2 haloVec = normalize(ghostVec) * uHaloWidth;
    vec3 distortion = vec3(-texelSize.x * uDistortion, 0.0, texelSize.x * uDistortion);
   
   // sample ghosts:  
    vec4 result = vec4(0.0);
    for (int i = 0; i < uGhosts; ++i) { 
        vec2 offset = fract(texcoord + ghostVec * float(i));
        float weight = length(vec2(0.5) - offset) / length(vec2(0.5));
        weight = pow(1.0 - weight, 10.0);
  
        result += texture(blurredSampler, offset);
    }
    
    result *= texture(uLensColor, length(vec2(0.5) - texcoord) / length(vec2(0.5)));

    vec4 lensMod = texture(uLensDirtTex, TexCoords);
    lensMod += texture(uLensStarTex, TexCoords);

    vec3 hdrColor = texture(sampler, TexCoords).rgb;
    vec4 SSR = texture(gReflectionSampler, TexCoords);
    vec3 bloom = texture(blurredSampler, TexCoords).rgb;
    vec3 mb = texture(MotionBlurSampler, TexCoords).rgb;

    vec2 fragcoord = gl_FragCoord.xy/Resolution;

    // Light offset. Kind of fake. See above.
    vec4 col = vec4(0.0);
    vec4 LightColor = vec4(218, 205, 118, 1.0);
    vec4 pos = projection * choppedView * vec4(sunPos, 1.0f);

    if(pos.x > 1.0 || pos.x < -1.0 || pos.y > 1.0 || pos.y < -1.0 || pos.z < 0.0 || sunPos.y < 0.0 || !lightShafts){ 
        col = vec4(0.0);
    } else {

        vec3 uvp = pos.rgb / pos.w;
        vec2 deltaTextCoord = vec2( (fragcoord-.5) - uvp.xy*0.5 );
        vec2 textCoo = fragcoord;
        deltaTextCoord *= 1.0 /  float(SAMPLES) * density;
        float illuminationDecay = 1.0;
    
        textCoo += deltaTextCoord*hash(textCoo);

        for(int i=0; i < SAMPLES ; i++)
        {
                 textCoo -= deltaTextCoord;
                 vec4 sample = texture2D(brightColorBuffer, textCoo );
            
                 sample *= illuminationDecay * weight;

                 col += sample;

                 illuminationDecay *= decay;
         }
    }

    col = mix(col, vec4(0.0), length(vec2(0.0) - pos.xy));
    col = vec4(clamp(col.x, 0.0, 1.0), clamp(col.y, 0.0, 1.0), clamp(col.z, 0.0, 1.0), col.w) * 0.25 * normalize(vec4(205, 109, 39, 1.0));

    fragcoord = gl_FragCoord.xy/Resolution;
    float vignete = 1.0 - smoothstep(0.9, 1.75, length(vec2(0.0) - (fragcoord * 2.0 - 1.0)));


    //float DOFRadius = smoothstep(-0.5, 1.75, length(vec2(0.0) - (fragcoord * 2.0 - 1.0)));

    //hdrColor = Bokeh(TexCoords, DOFRadius, .10, 1.0);

    //hdrColor = changeSaturation(hdrColor, .7);

    color.rgb  = HDR2((hdrColor + SSR.rgb) + col.rgb + bloom + (result.rgb * lensMod.rgb*5) ) * vignete;

    

    color.a = 1.0;

}