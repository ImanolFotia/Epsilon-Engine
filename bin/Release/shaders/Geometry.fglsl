#version 430 core

layout(location = 0) out vec4 gAlbedoSpec;
layout(location = 1) out vec4 gExpensiveNormal;
layout(location = 2) out vec4 gDepth;
layout(location = 3) out vec4 gExtraComponents; 
layout(location = 4) out vec4 gLightAccumulation;
layout(location = 5) out ivec4 gEntity;

layout (binding = 0) uniform sampler2D texture_diffuse;
layout (binding = 1) uniform sampler2D texture_specular;
layout (binding = 2) uniform sampler2D texture_normal;
layout (binding = 3) uniform sampler2D texture_height;
layout (binding = 4) uniform samplerCube skybox;

uniform bool using_color_diffuse = false;
uniform bool using_color_specular = false;
uniform bool using_color_normal = false;
uniform bool using_color_height = false;

uniform vec4 color_diffuse;
uniform vec4 color_specular;
uniform vec4 color_normal;
uniform vec4 color_height;

in VS_OUT{
  vec3 FragPos;
  vec3 Normal;
  vec2 TexCoords;
  mat3 TBN;
  mat3 TBN2;
  vec3 wFragPos;
} fs_in;

uniform vec3 viewPos;
uniform float time;
uniform int CubemapID;
uniform int AmbientProbeID;
uniform mat4 projection;
uniform bool parallaxOn;
uniform float u_scaleFactor = 1.1;
uniform ivec2 Resolution;
uniform bool isTransparent = false;

const float PI = 3.14159;

//Near and far camera planes (should be turned into uniforms at some point)
const float NEAR = 0.1;
const float FAR = 3000.0;

//Pre multiplied alpha constants (should be turned into uniforms at some point)
const float fAlphaMultiplier = 1.5;
const float fAlphaTest = 0.25;

//Spherical harmonics pre calculated values
const float Pi = 3.141592654f;
const float CosineA0 = Pi;
const float CosineA1 = (2.0 * Pi) / 3.0;
const float CosineA2 = Pi * 0.25;
const float C1 = 0.429043;
const float C2 = 0.511664;
const float C3 = 0.743125;
const float C4 = 0.886227;
const float C5 = 0.247708;

uniform int EntityId;

//Parallax corrected cubemap limits, should be converted into uniforms
const vec3 BoxMax = vec3(-6.5, 12, 19.5);
const vec3 BoxMin = vec3(-16, 0.5, -19);

//Inputs from previous shader stage, mostly used for motion blur
in vec4 PrevPosition;
in vec4 Position;
in flat int varCurrEnt;

// scale for restored amount of lighting
struct SphericalHarmonicsFormat {
  vec3 u_L00; float padding0;
  vec3 u_L1m1; float padding1;
  vec3 u_L10; float padding2;
  vec3 u_L11; float padding3;
  vec3 u_L2m2; float padding4;
  vec3 u_L2m1; float padding5;
  vec3 u_L20; float padding6;
  vec3 u_L21; float padding7;
  vec3 u_L22; float padding8;
};


layout(std430, binding = 1) buffer AmbientLightSSBO
{
    SphericalHarmonicsFormat ambientProbes[7][7][7];

} lp;

int WIDTH = 7;
int DEPTH = 7;


float LinearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0; // Back to NDC
    return ((2.0 * NEAR * FAR) / (FAR + NEAR - z * (FAR - NEAR)));
}

float deLinearizeDepth(float depth){
    float nonLinearDepth = (FAR + NEAR - 2.0 * NEAR * FAR / depth) / (FAR - NEAR);
    nonLinearDepth = (nonLinearDepth + 1.0) / 2.0;
    return nonLinearDepth;
}

uniform vec3 ambientDivider;

vec3 sphericalHarmonics(vec3 N, ivec3 index)
{
   ivec3 i = clamp(index, ivec3(0), ivec3(6));
   return
      // band 0, constant value, details of lowest frequency
      C4 * lp.ambientProbes[i.x][i.y][i.z].u_L00 +

      // band 1, oriented along main axes
      2.0 * C2 * lp.ambientProbes[i.x][i.y][i.z].u_L11 * N.x +
      2.0 * C2 * lp.ambientProbes[i.x][i.y][i.z].u_L1m1 * N.y +
      2.0 * C2 * lp.ambientProbes[i.x][i.y][i.z].u_L10 * N.z +

      // band 2, values depend on multiple axes, higher frequency details
      C1 * lp.ambientProbes[i.x][i.y][i.z].u_L22 * (N.x * N.x - N.y * N.y) +
      C3 * lp.ambientProbes[i.x][i.y][i.z].u_L20 * N.z * N.z - C5 * lp.ambientProbes[i.x][i.y][i.z].u_L20 +
      2.0 * C1 * lp.ambientProbes[i.x][i.y][i.z].u_L2m2 * N.x * N.y +
      2.0 * C1 * lp.ambientProbes[i.x][i.y][i.z].u_L21 * N.x * N.z +
      2.0 * C1 * lp.ambientProbes[i.x][i.y][i.z].u_L2m1 * N.y * N.z;
}

vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir)
{ 
    //Parallax mapping variables
    int numSteps = 0;
    float currentLayerDepth = 0.0;
    float weight = 0.0;
    float layerDepth = 0.0;
    // number of depth layers
    const float minLayers = 8;
    const float maxLayers = 32;
    float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));  
    // calculate the size of each layer
    layerDepth = 1.0 / numLayers;
    // depth of current layer
    // the amount to shift the texture coordinates per layer (from vector P)
    vec2 P = viewDir.xy / viewDir.z * 0.08; 
    vec2 deltaTexCoords = P / numLayers;
  
    // get initial values
    vec2  currentTexCoords     = texCoords;
    float currentDepthMapValue = texture(texture_height, currentTexCoords).b;

    int maxSteps = 16;
      
    while(currentLayerDepth < currentDepthMapValue)
    {
        if(numSteps >= maxSteps)
          break;
        // shift texture coordinates along direction of P
        currentTexCoords -= deltaTexCoords;
        // get depthmap value at current texture coordinates
        currentDepthMapValue = texture(texture_height, currentTexCoords).b;  
        // get depth of next layer
        currentLayerDepth += layerDepth;  

        numSteps++;
    }
    
    // get texture coordinates before collision (reverse operations)
    vec2 prevTexCoords = currentTexCoords + deltaTexCoords;

    // get depth after and before collision for linear interpolation
    float afterDepth  = currentDepthMapValue - currentLayerDepth;
    float beforeDepth = (texture(texture_height, prevTexCoords).b) - currentLayerDepth + layerDepth;
 
    // interpolation of texture coordinates
    weight = afterDepth / (afterDepth - beforeDepth);
    vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);

    return finalTexCoords;
}

vec3 bpcem (in vec3 v, vec3 Emax, vec3 Emin, vec3 Epos)
{ 
  vec3 nrdir = normalize(v);
  vec3 rbmax = (Emax - fs_in.wFragPos)/nrdir;
  vec3 rbmin = (Emin - fs_in.wFragPos)/nrdir;
  
  vec3 rbminmax;
  rbminmax.x = (nrdir.x>0.0)?rbmax.x:rbmin.x;
  rbminmax.y = (nrdir.y>0.0)?rbmax.y:rbmin.y;
  rbminmax.z = (nrdir.z>0.0)?rbmax.z:rbmin.z;   
  float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);
  vec3 posonbox = fs_in.wFragPos + nrdir * fa;
  return posonbox - Epos;
}

float rand(vec2 n) { 
  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
}
float noise(vec2 n) {
  const vec2 d = vec2(0.0, 1.0);
  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
  return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
}
float sum( vec3 v ) { return v.x+v.y+v.z; }
vec3 textureNoTile(in sampler2D tex, in vec2 x)
{
    float v = 0.5;
    float k = noise(x); // cheap (cache friendly) lookup
    
    float l = k*8.0;
    float i = floor( l );
    float f = fract( l );
    
    vec2 offa = sin(vec2(3.0,7.0)*(i+0.0)); // can replace with any other hash
    vec2 offb = sin(vec2(3.0,7.0)*(i+1.0)); // can replace with any other hash

    vec2 dx = dFdx(x), dy = dFdy(x);
    
    vec3 cola = textureGrad( tex, x + v*offa, dx, dy ).xyz;
    vec3 colb = textureGrad( tex, x + v*offb, dx, dy ).xyz;
    
    return mix( cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola-colb)) );
}

mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
    // get edge vectors of the pixel triangle
    vec3 dp1 = dFdx( p );
    vec3 dp2 = dFdy( p );
    vec2 duv1 = dFdx( uv );
    vec2 duv2 = dFdy( uv );
 
    // solve the linear system
    vec3 dp2perp = cross( dp2, N );
    vec3 dp1perp = cross( N, dp1 );
    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
    // construct a scale-invariant frame 
    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
    return mat3( T * invmax, B * invmax, N );
}

vec3 perturb_normal( vec3 N, vec3 V, vec2 texcoord )
{
    // assume N, the interpolated vertex normal and 
    // V, the view vector (vertex to eye)
   vec3 map = texture(texture_normal, texcoord ).xyz;
   map = map * 255./127. - 128./127.;
    mat3 TBN = cotangent_frame(N, -V, texcoord);
    return normalize(TBN * map);
}

const float threshold[16] = float[16](
    1./16., 9./16., 3./16., 11./16., 
    13./16., 5./16., 15./16., 7./16., 
    4./16., 12./16., 2./16., 10./16.,
    16./16., 8./16., 14./16., 6./16.);

float ScreenDoor(int x, int y, float v)
{
    return step(threshold[4*y+x],v);
}
int myround(float i, int v){
    return int(round(i/v) * v);
}
int to1D( int x, int y, int z, int xMax, int yMax, int zMax ) {
    return (z * xMax * yMax) + (y * xMax) + x;
}

vec3 bilinear( 
    inout float tx, 
    inout float ty, 
    in vec3 c00, 
    in vec3 c10, 
    in vec3 c01, 
    in vec3 c11) 
{ 
#if 1 
    vec3 a = c00 * (1. - tx) + c10 * tx; 
    vec3 b = c01 * (1. - tx) + c11 * tx; 
    return a * (1. - ty) + b * ty; 
#else 
    return (1 - tx) * (1 - ty) * c00 + 
        tx * (1 - ty) * c10 + 
        (1.f - tx) * ty * c01 + 
        tx * ty * c11; 
#endif 
} 

vec3 CosineInterpolate(
    inout float tx, 
    inout float ty, 
    in vec3 c00, 
    in vec3 c10, 
    in vec3 c01, 
    in vec3 c11) {

    float ax = (1.0 - cos(tx * PI)) / 2.0;  
    float ay = (1.0 - cos(ty * PI)) / 2.0;  

    vec3 a = (c00*(1.0 - ax) + c10*ax);
    vec3 b = (c01*(1.0 - ax) + c11*ax);

    return (a * (1.0 - ay) + b * ay);
}

void main()
{
  vec3 camDir = normalize((fs_in.TBN * viewPos) - (fs_in.TBN * fs_in.wFragPos));

  vec2 texCoords = vec2(0.0);  
  if(texture(texture_height, fs_in.TexCoords).b > 0.0 && parallaxOn)
    texCoords = ParallaxMapping(fs_in.TexCoords, camDir);
  else
    texCoords = fs_in.TexCoords;

  vec4 DiffuseTex = vec4(0.0); 
  vec2 MetallicHeight = vec2(0.0);
  vec3 normal_tex = vec3(0.0);
  vec3 r_tex = vec3(0.0);
  
  if(!using_color_diffuse) DiffuseTex = texture(texture_diffuse,texCoords);
  else DiffuseTex = color_diffuse;
  
  if(!using_color_specular) r_tex = texture(texture_specular,texCoords).xyz;
  else r_tex = color_specular.xyz;
  
  if(!using_color_normal) normal_tex = texture(texture_normal,texCoords).xyz;
  else normal_tex = color_normal.xyz;
  
  if(!using_color_height) MetallicHeight = texture(texture_height,texCoords).xy;
  else MetallicHeight = color_height.xy;


  ivec2 invFragCoord = ivec2(gl_FragCoord);///ivec2(fragCoord);  
  int indexX = int(mod(int(invFragCoord.x), 4)); 
  int indexY = int(mod(int(invFragCoord.y), 4));
  vec4 Diffuse = varCurrEnt == EntityId ? DiffuseTex * vec4(5.0, 0.0, 0.0, 1.0) : DiffuseTex;
  float alpha = Diffuse.a;

  float fNewAlpha = alpha * fAlphaMultiplier;

  if(fNewAlpha < fAlphaTest)
    discard;
      
  if(fNewAlpha > 1.0f)
    fNewAlpha = 1.0f; 

  if(isTransparent){  
    if(ScreenDoor(indexX, indexY, 0.5) < 1.0)
      discard;  
  }

  vec3 exNormal = normalize(perturb_normal(fs_in.Normal, normalize(fs_in.wFragPos - viewPos), texCoords));

  //Branchless normal flipper
  int negator = ( int(gl_FrontFacing) * 2 - 1 );
  gExpensiveNormal.rgb = normalize(negator * normalize( normalize( normal_tex * 2.0 - 1.0) * fs_in.TBN));

  float Roughness = clamp(r_tex.x, 0.05, 1.0);
  //float Roughness = RoughnessWetnessSpec.x;
  float SSS = r_tex.y;
  gLightAccumulation.a = 1.0;//SSS;
  gExpensiveNormal.a = clamp(Roughness*Roughness, 0.0, 1.0);

  vec4 CubeMapcolor = vec4(0.0);
  vec3 R = vec3(0.0);

  gAlbedoSpec.rgb = Diffuse.rgb;
  gAlbedoSpec.a = clamp(r_tex.z, 0.0, 1.0); //Specular multiplier
  
  gExtraComponents.x = min(MetallicHeight.x, 1.0); 
  gExtraComponents.y = MetallicHeight.y; 
  vec2 a = (Position.xy / Position.w) * 0.5 + 0.5;
  vec2 b = (PrevPosition.xy / PrevPosition.w) * 0.5 + 0.5;

  gExtraComponents.zw = vec2(a - b);
  const float MAX_REFLECTION_LOD = 4.0;

  CubeMapcolor = textureLod(skybox, /*bpcem(*/
                                      reflect(normalize(fs_in.wFragPos - viewPos), normalize(gExpensiveNormal.rgb))/*, 
                                      BoxMax, BoxMin, vec3(-11.0, 6.0, -8.0))/* reflect(normalize(fs_in.wFragPos - viewPos), normalize(gExpensiveNormal.rgb))*/, gExpensiveNormal.a * MAX_REFLECTION_LOD);


  ivec3 l_probeId;
  float mov = 0;//((sin(time)*0.5+0.5) * 10);
  float mov2 = 0;//((cos(time)*0.5+0.5) * 10);

  vec3 SPHFragPos = fs_in.wFragPos + vec3(34, 0, 31);

  vec3 gridSize = vec3(10, 5, 10);

  //l_probeId.x = //(myround(SPHFragPos.x, 10) + 35);
  //l_probeId.y = //(myround(SPHFragPos.y, 5));
  //l_probeId.z = //(myround(SPHFragPos.z, 10) + 35);
  l_probeId = ivec3(SPHFragPos) /*+ ivec3(34, 0, 34)*/;

  vec3 l_probe_pos = l_probeId;

  l_probeId /= ivec3(10, 5, 10);

  l_probeId.x = clamp(l_probeId.x, 0, 7); 
  l_probeId.y = clamp(l_probeId.y, 0, 7); 
  l_probeId.z = clamp(l_probeId.z, 0, 7); 

  int index = int(l_probeId.x) + (int(l_probeId.y)*7) + (int(l_probeId.z)*WIDTH*DEPTH);
  //int index = int(l_probeId.x) + WIDTH * (int(l_probeId.y) + DEPTH * int(l_probeId.z));

  gEntity.rgb = ivec3(EntityId);
  gEntity.a = 1;

  //index = clamp(index, 0, 7*7*7);
  vec3 c000 = sphericalHarmonics(normalize(gExpensiveNormal.rgb), l_probeId) * u_scaleFactor;

  vec3 c001 = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(0,0,1), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c010 = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(0,1,0), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c011 = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(0,1,1), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c100 = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(1,0,0), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c101 = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(1,0,1), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c110 = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(1,1,0), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c111 = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(1,1,1), ivec3(0), ivec3(6))) * u_scaleFactor;

  vec3 t; 
  ivec3 gi;
  vec3 g = SPHFragPos / gridSize; 
  gi = ivec3(g); 
  t = g - gi; 
  //vec3 e = bilinear(t.x, t.y, c000, c100, c010, c110); 
  //vec3 f = bilinear(t.x, t.y, c001, c101, c011, c111); 

  vec3 e = CosineInterpolate(t.x, t.y, c000, c100, c010, c110);
  vec3 f = CosineInterpolate(t.x, t.y, c001, c101, c011, c111); 
  vec3 c = e * (1.0 - t.z) + f * t.z; 

  gLightAccumulation.rgb = vec3(c);//clamp(c, vec3(0.01), vec3(100.0));//smoothstep(vec3(0.0), vec3(0.2), c);//mix(left, right, rl_d); 

  gDepth = vec4(gl_FragCoord.z, CubeMapcolor.rgb);
}
