#version 430 core

layout(location = 0) out vec4 gAlbedoSpec;
layout(location = 1) out vec4 gExpensiveNormal;
layout(location = 2) out vec4 gDepth;
layout(location = 3) out vec4 gExtraComponents; 
layout(location = 4) out vec4 gLightAccumulation;

layout (binding = 0) uniform sampler2D DiffuseSampler;
layout (binding = 1) uniform sampler2D NormalSampler;
layout (binding = 2) uniform sampler2D RoughnessSampler;
layout (binding = 3) uniform sampler2D MetallicSampler;
layout (binding = 4) uniform samplerCube Cubemap;
//layout (binding = 3) uniform sampler2D NormalSampler;

in vec3 Normal;
in vec2 TexCoords;
uniform int AmbientProbeID;

const float PI = 3.14159;

//Spherical harmonics pre calculated values
const float Pi = 3.141592654f;
const float CosineA0 = Pi;
const float CosineA1 = (2.0f * Pi) / 3.0f;
const float CosineA2 = Pi * 0.25f;
const float C1 = 0.429043;
const float C2 = 0.511664;
const float C3 = 0.743125;
const float C4 = 0.886227;
const float C5 = 0.247708;

in vec3 wFragPos;
//Parallax corrected cubemap limits, should be converted into uniforms
const vec3 BoxMax = vec3(-6.5, 12, 19.5);
const vec3 BoxMin = vec3(-16, 0.5, -19);

//Inputs from previous shader stage, mostly used for motion blur
in vec4 PrevPosition;
in vec4 Position;


// scale for restored amount of lighting
struct SphericalHarmonicsFormat {
  vec3 u_L00; float padding0;
  vec3 u_L1m1; float padding1;
  vec3 u_L10; float padding2;
  vec3 u_L11; float padding3;
  vec3 u_L2m2; float padding4;
  vec3 u_L2m1; float padding5;
  vec3 u_L20; float padding6;
  vec3 u_L21; float padding7;
  vec3 u_L22; float padding8;
};

layout(std430, binding = 1) buffer AmbientLightSSBO
{
    SphericalHarmonicsFormat ambientProbes[7][7][7];

} lp;

int WIDTH = 7;
int DEPTH = 7;

vec3 sphericalHarmonics(vec3 N, ivec3 index)
{
   ivec3 i = clamp(index, ivec3(0), ivec3(6));
   return
      // band 0, constant value, details of lowest frequency
      C4 * lp.ambientProbes[i.x][i.y][i.z].u_L00 +

      // band 1, oriented along main axes
      2.0 * C2 * lp.ambientProbes[i.x][i.y][i.z].u_L11 * N.x +
      2.0 * C2 * lp.ambientProbes[i.x][i.y][i.z].u_L1m1 * N.y +
      2.0 * C2 * lp.ambientProbes[i.x][i.y][i.z].u_L10 * N.z +

      // band 2, values depend on multiple axes, higher frequency details
      C1 * lp.ambientProbes[i.x][i.y][i.z].u_L22 * (N.x * N.x - N.y * N.y) +
      C3 * lp.ambientProbes[i.x][i.y][i.z].u_L20 * N.z * N.z - C5 * lp.ambientProbes[i.x][i.y][i.z].u_L20 +
      2.0 * C1 * lp.ambientProbes[i.x][i.y][i.z].u_L2m2 * N.x * N.y +
      2.0 * C1 * lp.ambientProbes[i.x][i.y][i.z].u_L21 * N.x * N.z +
      2.0 * C1 * lp.ambientProbes[i.x][i.y][i.z].u_L2m1 * N.y * N.z;
}

int myround(float i, int v){
    return int(round(i/v) * v);
}
int to1D( int x, int y, int z, int xMax, int yMax, int zMax ) {
    return (z * xMax * yMax) + (y * xMax) + x;
}

vec3 bilinear( 
    inout float tx, 
    inout float ty, 
    in vec3 c00, 
    in vec3 c10, 
    in vec3 c01, 
    in vec3 c11) 
{ 
#if 1 
    vec3 a = c00 * (1. - tx) + c10 * tx; 
    vec3 b = c01 * (1. - tx) + c11 * tx; 
    return a * (1. - ty) + b * ty; 
#else 
    return (1 - tx) * (1 - ty) * c00 + 
        tx * (1 - ty) * c10 + 
        (1.f - tx) * ty * c01 + 
        tx * ty * c11; 
#endif 
} 

vec3 CosineInterpolate(
    inout float tx, 
    inout float ty, 
    in vec3 c00, 
    in vec3 c10, 
    in vec3 c01, 
    in vec3 c11) {

    float ax = (1.0 - cos(tx * PI)) / 2.0;  
    float ay = (1.0 - cos(ty * PI)) / 2.0;  

    vec3 a = (c00*(1.0 - ax) + c10*ax);
    vec3 b = (c01*(1.0 - ax) + c11*ax);

    return (a * (1.0 - ay) + b * ay);
}



in mat3 TBN;

uniform float u_scaleFactor = 2.5;
void main()
{
  vec2 texCoords = TexCoords;
  int negator = ( int(gl_FrontFacing) * 2 - 1 );
  texCoords.x *= -1 * negator;

	if(texture(DiffuseSampler, texCoords).a < 0.4) discard;

  vec3 normalColor = vec3(128, 128, 255);//
  
  vec3 r_tex = texture(RoughnessSampler, texCoords).xyz;

	vec3 NormalTexture = normalize(texture(NormalSampler, texCoords).rgb * 2.0 - 1.0);
	gAlbedoSpec.rgb = texture(DiffuseSampler, texCoords).rgb;
  gAlbedoSpec.a = r_tex.z;
  gExpensiveNormal.rgb = normalize(negator * normalize(NormalTexture * TBN));
	gExpensiveNormal.a = r_tex.x;
  
  vec2 MetallicHeight = texture(MetallicSampler, texCoords).rg;

	gDepth.x = gl_FragCoord.z;
	gDepth.yzw = vec3(0.0);
	gExtraComponents = vec4(0.0, 0.0, 0.0, 0.0);
  gExtraComponents.x = min(MetallicHeight.x, 1.0); 
  gExtraComponents.y = MetallicHeight.y; 
  gLightAccumulation.a = r_tex.y;


  
  ivec3 l_probeId;
  float mov = 0;//((sin(time)*0.5+0.5) * 10);
  float mov2 = 0;//((cos(time)*0.5+0.5) * 10);

  vec3 SPHFragPos = wFragPos + vec3(34, 0, 34);

  vec3 gridSize = vec3(10, 5, 10);

  //l_probeId.x = //(myround(SPHFragPos.x, 10) + 35);
  //l_probeId.y = //(myround(SPHFragPos.y, 5));
  //l_probeId.z = //(myround(SPHFragPos.z, 10) + 35);
  l_probeId = ivec3(SPHFragPos) /*+ ivec3(34, 0, 34)*/;

  vec3 l_probe_pos = l_probeId;

  l_probeId /= ivec3(10, 5, 10);

  l_probeId.x = clamp(l_probeId.x, 0, 6); 
  l_probeId.y = clamp(l_probeId.y, 0, 6); 
  l_probeId.z = clamp(l_probeId.z, 0, 6); 

  int index = int(l_probeId.x) + (int(l_probeId.y)*WIDTH) + (int(l_probeId.z)*WIDTH*DEPTH);
  //int index = int(l_probeId.x) + WIDTH * (int(l_probeId.y) + DEPTH * int(l_probeId.z));

  

  //index = clamp(index, 0, 7*7*7);
  vec3 c000 = sphericalHarmonics(normalize(gExpensiveNormal.rgb), l_probeId) * u_scaleFactor;
  vec3 c010    = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(0,1,0), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c011 = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(0,1,1), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c100  = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(1,0,0), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c110   = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(1,1,0), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c001  = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(0,0,1), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c101   = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(1,0,1), ivec3(0), ivec3(6))) * u_scaleFactor;
  vec3 c111   = sphericalHarmonics(normalize(gExpensiveNormal.rgb), clamp(l_probeId + ivec3(1,1,1), ivec3(0), ivec3(6))) * u_scaleFactor;

  vec3 t; 
  ivec3 gi;
  vec3 g = SPHFragPos / gridSize; gi = ivec3(g); t = g - gi; 
  //vec3 e = bilinear(t.x, t.y, c000, c100, c010, c110); 
  //vec3 f = bilinear(t.x, t.y, c001, c101, c011, c111); 

  vec3 e = CosineInterpolate(t.x, t.y, c000, c100, c010, c110);
  vec3 f = CosineInterpolate(t.x, t.y, c001, c101, c011, c111); 
  vec3 c = e * (1.0 - t.z) + f * t.z; 

  gLightAccumulation.rgb = clamp(c, vec3(0.01), vec3(1.0));//mix(left, right, rl_d); 
}